<?php
/**
 * StudiesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://book.orthanc-server.com/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://book.orthanc-server.com/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.11.3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * StudiesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class StudiesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'studiesGet' => [
            'application/json',
        ],
        'studiesIdAnonymizePost' => [
            'application/json',
        ],
        'studiesIdArchiveGet' => [
            'application/json',
        ],
        'studiesIdArchivePost' => [
            'application/json',
        ],
        'studiesIdAttachmentsGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameCompressPost' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameCompressedDataGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameCompressedMd5Get' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameCompressedSizeGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameDataGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameDelete' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameInfoGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameIsCompressedGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameMd5Get' => [
            'application/json',
        ],
        'studiesIdAttachmentsNamePut' => [
            'application/octet-stream',
        ],
        'studiesIdAttachmentsNameSizeGet' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameUncompressPost' => [
            'application/json',
        ],
        'studiesIdAttachmentsNameVerifyMd5Post' => [
            'application/json',
        ],
        'studiesIdDelete' => [
            'application/json',
        ],
        'studiesIdGet' => [
            'application/json',
        ],
        'studiesIdInstancesGet' => [
            'application/json',
        ],
        'studiesIdInstancesTagsGet' => [
            'application/json',
        ],
        'studiesIdMediaGet' => [
            'application/json',
        ],
        'studiesIdMediaPost' => [
            'application/json',
        ],
        'studiesIdMergePost' => [
            'application/json',
        ],
        'studiesIdMetadataGet' => [
            'application/json',
        ],
        'studiesIdMetadataNameDelete' => [
            'application/json',
        ],
        'studiesIdMetadataNameGet' => [
            'application/json',
        ],
        'studiesIdMetadataNamePut' => [
            'text/plain',
        ],
        'studiesIdModifyPost' => [
            'application/json',
        ],
        'studiesIdModuleGet' => [
            'application/json',
        ],
        'studiesIdModulePatientGet' => [
            'application/json',
        ],
        'studiesIdPatientGet' => [
            'application/json',
        ],
        'studiesIdReconstructPost' => [
            'application/json',
        ],
        'studiesIdSeriesGet' => [
            'application/json',
        ],
        'studiesIdSharedTagsGet' => [
            'application/json',
        ],
        'studiesIdSplitPost' => [
            'application/json',
        ],
        'studiesIdStatisticsGet' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation studiesGet
     *
     * List the available studies
     *
     * @param  string $expand If present, retrieve detailed information about the individual studies (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesGet($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['studiesGet'][0])
    {
        list($response) = $this->studiesGetWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType);
        return $response;
    }

    /**
     * Operation studiesGetWithHttpInfo
     *
     * List the available studies
     *
     * @param  string $expand If present, retrieve detailed information about the individual studies (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesGetWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['studiesGet'][0])
    {
        $request = $this->studiesGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesGetAsync
     *
     * List the available studies
     *
     * @param  string $expand If present, retrieve detailed information about the individual studies (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesGetAsync($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['studiesGet'][0])
    {
        return $this->studiesGetAsyncWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesGetAsyncWithHttpInfo
     *
     * List the available studies
     *
     * @param  string $expand If present, retrieve detailed information about the individual studies (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesGetAsyncWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['studiesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesGet'
     *
     * @param  string $expand If present, retrieve detailed information about the individual studies (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesGetRequest($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['studiesGet'][0])
    {








        $resourcePath = '/studies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAnonymizePost
     *
     * Anonymize study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function studiesIdAnonymizePost($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['studiesIdAnonymizePost'][0])
    {
        list($response) = $this->studiesIdAnonymizePostWithHttpInfo($id, $patients_id_anonymize_post_request, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAnonymizePostWithHttpInfo
     *
     * Anonymize study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAnonymizePostWithHttpInfo($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['studiesIdAnonymizePost'][0])
    {
        $request = $this->studiesIdAnonymizePostRequest($id, $patients_id_anonymize_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAnonymizePostAsync
     *
     * Anonymize study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAnonymizePostAsync($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['studiesIdAnonymizePost'][0])
    {
        return $this->studiesIdAnonymizePostAsyncWithHttpInfo($id, $patients_id_anonymize_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAnonymizePostAsyncWithHttpInfo
     *
     * Anonymize study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAnonymizePostAsyncWithHttpInfo($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['studiesIdAnonymizePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->studiesIdAnonymizePostRequest($id, $patients_id_anonymize_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAnonymizePost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAnonymizePostRequest($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['studiesIdAnonymizePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAnonymizePost'
            );
        }



        $resourcePath = '/studies/{id}/anonymize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_anonymize_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_anonymize_post_request));
            } else {
                $httpBody = $patients_id_anonymize_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdArchiveGet
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdArchiveGet($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdArchiveGet'][0])
    {
        list($response) = $this->studiesIdArchiveGetWithHttpInfo($id, $filename, $transcode, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdArchiveGetWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdArchiveGetWithHttpInfo($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdArchiveGet'][0])
    {
        $request = $this->studiesIdArchiveGetRequest($id, $filename, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdArchiveGetAsync
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdArchiveGetAsync($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdArchiveGet'][0])
    {
        return $this->studiesIdArchiveGetAsyncWithHttpInfo($id, $filename, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdArchiveGetAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdArchiveGetAsyncWithHttpInfo($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdArchiveGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdArchiveGetRequest($id, $filename, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdArchiveGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdArchiveGetRequest($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdArchiveGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdArchiveGet'
            );
        }




        $resourcePath = '/studies/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filename,
            'filename', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdArchivePost
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdArchivePost200Response
     */
    public function studiesIdArchivePost($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['studiesIdArchivePost'][0])
    {
        list($response) = $this->studiesIdArchivePostWithHttpInfo($id, $patients_id_archive_post_request, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdArchivePostWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdArchivePostWithHttpInfo($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['studiesIdArchivePost'][0])
    {
        $request = $this->studiesIdArchivePostRequest($id, $patients_id_archive_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdArchivePostAsync
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdArchivePostAsync($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['studiesIdArchivePost'][0])
    {
        return $this->studiesIdArchivePostAsyncWithHttpInfo($id, $patients_id_archive_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdArchivePostAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdArchivePostAsyncWithHttpInfo($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['studiesIdArchivePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
        $request = $this->studiesIdArchivePostRequest($id, $patients_id_archive_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdArchivePost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdArchivePostRequest($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['studiesIdArchivePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdArchivePost'
            );
        }



        $resourcePath = '/studies/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_archive_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_archive_post_request));
            } else {
                $httpBody = $patients_id_archive_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsGet
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsGet($id, $full = null, string $contentType = self::contentTypes['studiesIdAttachmentsGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsGetWithHttpInfo($id, $full, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsGetWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsGetWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['studiesIdAttachmentsGet'][0])
    {
        $request = $this->studiesIdAttachmentsGetRequest($id, $full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsGetAsync
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsGetAsync($id, $full = null, string $contentType = self::contentTypes['studiesIdAttachmentsGet'][0])
    {
        return $this->studiesIdAttachmentsGetAsyncWithHttpInfo($id, $full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsGetAsyncWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsGetAsyncWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['studiesIdAttachmentsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsGetRequest($id, $full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsGetRequest($id, $full = null, string $contentType = self::contentTypes['studiesIdAttachmentsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressPost
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdAttachmentsNameCompressPost($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressPost'][0])
    {
        $this->studiesIdAttachmentsNameCompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation studiesIdAttachmentsNameCompressPostWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameCompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressPost'][0])
    {
        $request = $this->studiesIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameCompressPostAsync
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressPostAsync($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressPost'][0])
    {
        return $this->studiesIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressPostAsyncWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressPost'][0])
    {
        $returnType = '';
        $request = $this->studiesIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameCompressPost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameCompressPostRequest($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameCompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameCompressPost'
            );
        }


        $resourcePath = '/studies/{id}/attachments/{name}/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedDataGet
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameCompressedDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedDataGetWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'][0])
    {
        $request = $this->studiesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedDataGetAsync
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressedDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'][0])
    {
        return $this->studiesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameCompressedDataGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameCompressedDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameCompressedDataGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/compressed-data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedMd5Get
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameCompressedMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedMd5GetWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'][0])
    {
        $request = $this->studiesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedMd5GetAsync
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressedMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'][0])
    {
        return $this->studiesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameCompressedMd5Get'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameCompressedMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameCompressedMd5Get'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/compressed-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedSizeGet
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameCompressedSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedSizeGetWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'][0])
    {
        $request = $this->studiesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedSizeGetAsync
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressedSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'][0])
    {
        return $this->studiesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameCompressedSizeGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameCompressedSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameCompressedSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameCompressedSizeGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/compressed-size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameDataGet
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDataGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameDataGetWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDataGet'][0])
    {
        $request = $this->studiesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameDataGetAsync
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDataGet'][0])
    {
        return $this->studiesIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameDataGetAsyncWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameDataGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameDataGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameDelete
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdAttachmentsNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDelete'][0])
    {
        $this->studiesIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation studiesIdAttachmentsNameDeleteWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDelete'][0])
    {
        $request = $this->studiesIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameDeleteAsync
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDelete'][0])
    {
        return $this->studiesIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameDeleteAsyncWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDelete'][0])
    {
        $returnType = '';
        $request = $this->studiesIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameDelete'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameDelete'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameInfoGet
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameInfoGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameInfoGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameInfoGetWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameInfoGet'][0])
    {
        $request = $this->studiesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameInfoGetAsync
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameInfoGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameInfoGet'][0])
    {
        return $this->studiesIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameInfoGetAsyncWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameInfoGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameInfoGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameInfoGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameInfoGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameInfoGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameIsCompressedGet
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameIsCompressedGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameIsCompressedGetWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'][0])
    {
        $request = $this->studiesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameIsCompressedGetAsync
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameIsCompressedGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'][0])
    {
        return $this->studiesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameIsCompressedGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameIsCompressedGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameIsCompressedGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameIsCompressedGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/is-compressed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameMd5Get
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameMd5Get'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameMd5GetWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameMd5Get'][0])
    {
        $request = $this->studiesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameMd5GetAsync
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameMd5Get'][0])
    {
        return $this->studiesIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameMd5Get'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameMd5Get'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNamePut
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdAttachmentsNamePut'][0])
    {
        list($response) = $this->studiesIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNamePutWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdAttachmentsNamePut'][0])
    {
        $request = $this->studiesIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNamePutAsync
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdAttachmentsNamePut'][0])
    {
        return $this->studiesIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNamePutAsyncWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdAttachmentsNamePut'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNamePut'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdAttachmentsNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNamePut'
            );
        }




        $resourcePath = '/studies/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameSizeGet
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameSizeGet'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameSizeGetWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameSizeGet'][0])
    {
        $request = $this->studiesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameSizeGetAsync
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameSizeGet'][0])
    {
        return $this->studiesIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameSizeGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdAttachmentsNameSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameSizeGet'
            );
        }



        $resourcePath = '/studies/{id}/attachments/{name}/size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameUncompressPost
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdAttachmentsNameUncompressPost($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameUncompressPost'][0])
    {
        $this->studiesIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation studiesIdAttachmentsNameUncompressPostWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameUncompressPost'][0])
    {
        $request = $this->studiesIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameUncompressPostAsync
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameUncompressPostAsync($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameUncompressPost'][0])
    {
        return $this->studiesIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameUncompressPostAsyncWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameUncompressPost'][0])
    {
        $returnType = '';
        $request = $this->studiesIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameUncompressPost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameUncompressPostRequest($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameUncompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameUncompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameUncompressPost'
            );
        }


        $resourcePath = '/studies/{id}/attachments/{name}/uncompress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdAttachmentsNameVerifyMd5Post
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdAttachmentsNameVerifyMd5Post($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'][0])
    {
        list($response) = $this->studiesIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdAttachmentsNameVerifyMd5PostWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'][0])
    {
        $request = $this->studiesIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdAttachmentsNameVerifyMd5PostAsync
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameVerifyMd5PostAsync($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'][0])
    {
        return $this->studiesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdAttachmentsNameVerifyMd5Post'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdAttachmentsNameVerifyMd5PostRequest($id, $name, string $contentType = self::contentTypes['studiesIdAttachmentsNameVerifyMd5Post'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdAttachmentsNameVerifyMd5Post'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdAttachmentsNameVerifyMd5Post'
            );
        }


        $resourcePath = '/studies/{id}/attachments/{name}/verify-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdDelete
     *
     * Delete some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdDelete($id, string $contentType = self::contentTypes['studiesIdDelete'][0])
    {
        $this->studiesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation studiesIdDeleteWithHttpInfo
     *
     * Delete some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['studiesIdDelete'][0])
    {
        $request = $this->studiesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdDeleteAsync
     *
     * Delete some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdDeleteAsync($id, string $contentType = self::contentTypes['studiesIdDelete'][0])
    {
        return $this->studiesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdDeleteAsyncWithHttpInfo
     *
     * Delete some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['studiesIdDelete'][0])
    {
        $returnType = '';
        $request = $this->studiesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdDelete'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdDeleteRequest($id, string $contentType = self::contentTypes['studiesIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdDelete'
            );
        }


        $resourcePath = '/studies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdGet
     *
     * Get information about some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdGet'][0])
    {
        list($response) = $this->studiesIdGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdGetWithHttpInfo
     *
     * Get information about some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdGet'][0])
    {
        $request = $this->studiesIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdGetAsync
     *
     * Get information about some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdGet'][0])
    {
        return $this->studiesIdGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdGetAsyncWithHttpInfo
     *
     * Get information about some study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdGet'
            );
        }





        $resourcePath = '/studies/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdInstancesGet
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdInstancesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdInstancesGet'][0])
    {
        list($response) = $this->studiesIdInstancesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdInstancesGetWithHttpInfo
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdInstancesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdInstancesGet'][0])
    {
        $request = $this->studiesIdInstancesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdInstancesGetAsync
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdInstancesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdInstancesGet'][0])
    {
        return $this->studiesIdInstancesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdInstancesGetAsyncWithHttpInfo
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdInstancesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdInstancesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdInstancesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdInstancesGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdInstancesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdInstancesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdInstancesGet'
            );
        }





        $resourcePath = '/studies/{id}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdInstancesTagsGet
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdInstancesTagsGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdInstancesTagsGet'][0])
    {
        list($response) = $this->studiesIdInstancesTagsGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdInstancesTagsGetWithHttpInfo
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdInstancesTagsGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdInstancesTagsGet'][0])
    {
        $request = $this->studiesIdInstancesTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdInstancesTagsGetAsync
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdInstancesTagsGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdInstancesTagsGet'][0])
    {
        return $this->studiesIdInstancesTagsGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdInstancesTagsGetAsyncWithHttpInfo
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdInstancesTagsGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdInstancesTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdInstancesTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdInstancesTagsGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdInstancesTagsGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdInstancesTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdInstancesTagsGet'
            );
        }





        $resourcePath = '/studies/{id}/instances-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMediaGet
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdMediaGet($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdMediaGet'][0])
    {
        list($response) = $this->studiesIdMediaGetWithHttpInfo($id, $extended, $filename, $transcode, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdMediaGetWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMediaGetWithHttpInfo($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdMediaGet'][0])
    {
        $request = $this->studiesIdMediaGetRequest($id, $extended, $filename, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMediaGetAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMediaGetAsync($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdMediaGet'][0])
    {
        return $this->studiesIdMediaGetAsyncWithHttpInfo($id, $extended, $filename, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMediaGetAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMediaGetAsyncWithHttpInfo($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdMediaGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdMediaGetRequest($id, $extended, $filename, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMediaGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMediaGetRequest($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['studiesIdMediaGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMediaGet'
            );
        }





        $resourcePath = '/studies/{id}/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extended,
            'extended', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filename,
            'filename', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMediaPost
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdArchivePost200Response
     */
    public function studiesIdMediaPost($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['studiesIdMediaPost'][0])
    {
        list($response) = $this->studiesIdMediaPostWithHttpInfo($id, $patients_id_media_post_request, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdMediaPostWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMediaPostWithHttpInfo($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['studiesIdMediaPost'][0])
    {
        $request = $this->studiesIdMediaPostRequest($id, $patients_id_media_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMediaPostAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMediaPostAsync($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['studiesIdMediaPost'][0])
    {
        return $this->studiesIdMediaPostAsyncWithHttpInfo($id, $patients_id_media_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMediaPostAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMediaPostAsyncWithHttpInfo($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['studiesIdMediaPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
        $request = $this->studiesIdMediaPostRequest($id, $patients_id_media_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMediaPost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMediaPostRequest($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['studiesIdMediaPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMediaPost'
            );
        }



        $resourcePath = '/studies/{id}/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_media_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_media_post_request));
            } else {
                $httpBody = $patients_id_media_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMergePost
     *
     * Merge study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdMergePostRequest $studies_id_merge_post_request studies_id_merge_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMergePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function studiesIdMergePost($id, $studies_id_merge_post_request = null, string $contentType = self::contentTypes['studiesIdMergePost'][0])
    {
        list($response) = $this->studiesIdMergePostWithHttpInfo($id, $studies_id_merge_post_request, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdMergePostWithHttpInfo
     *
     * Merge study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdMergePostRequest $studies_id_merge_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMergePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMergePostWithHttpInfo($id, $studies_id_merge_post_request = null, string $contentType = self::contentTypes['studiesIdMergePost'][0])
    {
        $request = $this->studiesIdMergePostRequest($id, $studies_id_merge_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMergePostAsync
     *
     * Merge study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdMergePostRequest $studies_id_merge_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMergePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMergePostAsync($id, $studies_id_merge_post_request = null, string $contentType = self::contentTypes['studiesIdMergePost'][0])
    {
        return $this->studiesIdMergePostAsyncWithHttpInfo($id, $studies_id_merge_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMergePostAsyncWithHttpInfo
     *
     * Merge study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdMergePostRequest $studies_id_merge_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMergePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMergePostAsyncWithHttpInfo($id, $studies_id_merge_post_request = null, string $contentType = self::contentTypes['studiesIdMergePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->studiesIdMergePostRequest($id, $studies_id_merge_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMergePost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdMergePostRequest $studies_id_merge_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMergePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMergePostRequest($id, $studies_id_merge_post_request = null, string $contentType = self::contentTypes['studiesIdMergePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMergePost'
            );
        }



        $resourcePath = '/studies/{id}/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($studies_id_merge_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($studies_id_merge_post_request));
            } else {
                $httpBody = $studies_id_merge_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMetadataGet
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdMetadataGet($id, $expand = null, string $contentType = self::contentTypes['studiesIdMetadataGet'][0])
    {
        list($response) = $this->studiesIdMetadataGetWithHttpInfo($id, $expand, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdMetadataGetWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMetadataGetWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['studiesIdMetadataGet'][0])
    {
        $request = $this->studiesIdMetadataGetRequest($id, $expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMetadataGetAsync
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataGetAsync($id, $expand = null, string $contentType = self::contentTypes['studiesIdMetadataGet'][0])
    {
        return $this->studiesIdMetadataGetAsyncWithHttpInfo($id, $expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMetadataGetAsyncWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataGetAsyncWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['studiesIdMetadataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdMetadataGetRequest($id, $expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMetadataGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMetadataGetRequest($id, $expand = null, string $contentType = self::contentTypes['studiesIdMetadataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMetadataGet'
            );
        }



        $resourcePath = '/studies/{id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMetadataNameDelete
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdMetadataNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameDelete'][0])
    {
        $this->studiesIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation studiesIdMetadataNameDeleteWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameDelete'][0])
    {
        $request = $this->studiesIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMetadataNameDeleteAsync
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameDelete'][0])
    {
        return $this->studiesIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMetadataNameDeleteAsyncWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameDelete'][0])
    {
        $returnType = '';
        $request = $this->studiesIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMetadataNameDelete'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMetadataNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMetadataNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdMetadataNameDelete'
            );
        }



        $resourcePath = '/studies/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMetadataNameGet
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdMetadataNameGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameGet'][0])
    {
        list($response) = $this->studiesIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdMetadataNameGetWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameGet'][0])
    {
        $request = $this->studiesIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMetadataNameGetAsync
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataNameGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameGet'][0])
    {
        return $this->studiesIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMetadataNameGetAsyncWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMetadataNameGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMetadataNameGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['studiesIdMetadataNameGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMetadataNameGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdMetadataNameGet'
            );
        }



        $resourcePath = '/studies/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdMetadataNamePut
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdMetadataNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdMetadataNamePut'][0])
    {
        $this->studiesIdMetadataNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
    }

    /**
     * Operation studiesIdMetadataNamePutWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdMetadataNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdMetadataNamePut'][0])
    {
        $request = $this->studiesIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdMetadataNamePutAsync
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdMetadataNamePut'][0])
    {
        return $this->studiesIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdMetadataNamePutAsyncWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdMetadataNamePut'][0])
    {
        $returnType = '';
        $request = $this->studiesIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdMetadataNamePut'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdMetadataNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['studiesIdMetadataNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdMetadataNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling studiesIdMetadataNamePut'
            );
        }




        $resourcePath = '/studies/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdModifyPost
     *
     * Modify study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function studiesIdModifyPost($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['studiesIdModifyPost'][0])
    {
        list($response) = $this->studiesIdModifyPostWithHttpInfo($id, $patients_id_modify_post_request, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdModifyPostWithHttpInfo
     *
     * Modify study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdModifyPostWithHttpInfo($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['studiesIdModifyPost'][0])
    {
        $request = $this->studiesIdModifyPostRequest($id, $patients_id_modify_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdModifyPostAsync
     *
     * Modify study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdModifyPostAsync($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['studiesIdModifyPost'][0])
    {
        return $this->studiesIdModifyPostAsyncWithHttpInfo($id, $patients_id_modify_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdModifyPostAsyncWithHttpInfo
     *
     * Modify study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdModifyPostAsyncWithHttpInfo($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['studiesIdModifyPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->studiesIdModifyPostRequest($id, $patients_id_modify_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdModifyPost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdModifyPostRequest($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['studiesIdModifyPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdModifyPost'
            );
        }



        $resourcePath = '/studies/{id}/modify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_modify_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_modify_post_request));
            } else {
                $httpBody = $patients_id_modify_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdModuleGet
     *
     * Get study module
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdModuleGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModuleGet'][0])
    {
        list($response) = $this->studiesIdModuleGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdModuleGetWithHttpInfo
     *
     * Get study module
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdModuleGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModuleGet'][0])
    {
        $request = $this->studiesIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdModuleGetAsync
     *
     * Get study module
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdModuleGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModuleGet'][0])
    {
        return $this->studiesIdModuleGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdModuleGetAsyncWithHttpInfo
     *
     * Get study module
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdModuleGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModuleGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdModuleGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdModuleGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModuleGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdModuleGet'
            );
        }





        $resourcePath = '/studies/{id}/module';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdModulePatientGet
     *
     * Get patient module of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModulePatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdModulePatientGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModulePatientGet'][0])
    {
        list($response) = $this->studiesIdModulePatientGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdModulePatientGetWithHttpInfo
     *
     * Get patient module of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModulePatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdModulePatientGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModulePatientGet'][0])
    {
        $request = $this->studiesIdModulePatientGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdModulePatientGetAsync
     *
     * Get patient module of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModulePatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdModulePatientGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModulePatientGet'][0])
    {
        return $this->studiesIdModulePatientGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdModulePatientGetAsyncWithHttpInfo
     *
     * Get patient module of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModulePatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdModulePatientGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModulePatientGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdModulePatientGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdModulePatientGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdModulePatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdModulePatientGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdModulePatientGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdModulePatientGet'
            );
        }





        $resourcePath = '/studies/{id}/module-patient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdPatientGet
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdPatientGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdPatientGet'][0])
    {
        list($response) = $this->studiesIdPatientGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdPatientGetWithHttpInfo
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdPatientGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdPatientGet'][0])
    {
        $request = $this->studiesIdPatientGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdPatientGetAsync
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdPatientGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdPatientGet'][0])
    {
        return $this->studiesIdPatientGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdPatientGetAsyncWithHttpInfo
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdPatientGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdPatientGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdPatientGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdPatientGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdPatientGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdPatientGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdPatientGet'
            );
        }





        $resourcePath = '/studies/{id}/patient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdReconstructPost
     *
     * Reconstruct tags &amp; optionally files of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function studiesIdReconstructPost($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['studiesIdReconstructPost'][0])
    {
        $this->studiesIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType);
    }

    /**
     * Operation studiesIdReconstructPostWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['studiesIdReconstructPost'][0])
    {
        $request = $this->studiesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdReconstructPostAsync
     *
     * Reconstruct tags &amp; optionally files of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdReconstructPostAsync($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['studiesIdReconstructPost'][0])
    {
        return $this->studiesIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdReconstructPostAsyncWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['studiesIdReconstructPost'][0])
    {
        $returnType = '';
        $request = $this->studiesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdReconstructPost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['studiesIdReconstructPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdReconstructPost'
            );
        }



        $resourcePath = '/studies/{id}/reconstruct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($instances_id_reconstruct_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($instances_id_reconstruct_post_request));
            } else {
                $httpBody = $instances_id_reconstruct_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdSeriesGet
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdSeriesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdSeriesGet'][0])
    {
        list($response) = $this->studiesIdSeriesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdSeriesGetWithHttpInfo
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdSeriesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdSeriesGet'][0])
    {
        $request = $this->studiesIdSeriesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdSeriesGetAsync
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdSeriesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdSeriesGet'][0])
    {
        return $this->studiesIdSeriesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdSeriesGetAsyncWithHttpInfo
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdSeriesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdSeriesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdSeriesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdSeriesGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdSeriesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['studiesIdSeriesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdSeriesGet'
            );
        }





        $resourcePath = '/studies/{id}/series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdSharedTagsGet
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function studiesIdSharedTagsGet($id, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdSharedTagsGet'][0])
    {
        list($response) = $this->studiesIdSharedTagsGetWithHttpInfo($id, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdSharedTagsGetWithHttpInfo
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdSharedTagsGetWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdSharedTagsGet'][0])
    {
        $request = $this->studiesIdSharedTagsGetRequest($id, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdSharedTagsGetAsync
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdSharedTagsGetAsync($id, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdSharedTagsGet'][0])
    {
        return $this->studiesIdSharedTagsGetAsyncWithHttpInfo($id, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdSharedTagsGetAsyncWithHttpInfo
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdSharedTagsGetAsyncWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdSharedTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->studiesIdSharedTagsGetRequest($id, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdSharedTagsGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdSharedTagsGetRequest($id, $short = null, $simplify = null, string $contentType = self::contentTypes['studiesIdSharedTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdSharedTagsGet'
            );
        }




        $resourcePath = '/studies/{id}/shared-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdSplitPost
     *
     * Split study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdSplitPostRequest $studies_id_split_post_request studies_id_split_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSplitPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function studiesIdSplitPost($id, $studies_id_split_post_request = null, string $contentType = self::contentTypes['studiesIdSplitPost'][0])
    {
        list($response) = $this->studiesIdSplitPostWithHttpInfo($id, $studies_id_split_post_request, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdSplitPostWithHttpInfo
     *
     * Split study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdSplitPostRequest $studies_id_split_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSplitPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdSplitPostWithHttpInfo($id, $studies_id_split_post_request = null, string $contentType = self::contentTypes['studiesIdSplitPost'][0])
    {
        $request = $this->studiesIdSplitPostRequest($id, $studies_id_split_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdSplitPostAsync
     *
     * Split study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdSplitPostRequest $studies_id_split_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSplitPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdSplitPostAsync($id, $studies_id_split_post_request = null, string $contentType = self::contentTypes['studiesIdSplitPost'][0])
    {
        return $this->studiesIdSplitPostAsyncWithHttpInfo($id, $studies_id_split_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdSplitPostAsyncWithHttpInfo
     *
     * Split study
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdSplitPostRequest $studies_id_split_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSplitPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdSplitPostAsyncWithHttpInfo($id, $studies_id_split_post_request = null, string $contentType = self::contentTypes['studiesIdSplitPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->studiesIdSplitPostRequest($id, $studies_id_split_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdSplitPost'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  \OpenAPI\Client\Model\StudiesIdSplitPostRequest $studies_id_split_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdSplitPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdSplitPostRequest($id, $studies_id_split_post_request = null, string $contentType = self::contentTypes['studiesIdSplitPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdSplitPost'
            );
        }



        $resourcePath = '/studies/{id}/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($studies_id_split_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($studies_id_split_post_request));
            } else {
                $httpBody = $studies_id_split_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation studiesIdStatisticsGet
     *
     * Get study statistics
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StudiesIdStatisticsGet200Response
     */
    public function studiesIdStatisticsGet($id, string $contentType = self::contentTypes['studiesIdStatisticsGet'][0])
    {
        list($response) = $this->studiesIdStatisticsGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation studiesIdStatisticsGetWithHttpInfo
     *
     * Get study statistics
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StudiesIdStatisticsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function studiesIdStatisticsGetWithHttpInfo($id, string $contentType = self::contentTypes['studiesIdStatisticsGet'][0])
    {
        $request = $this->studiesIdStatisticsGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StudiesIdStatisticsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\StudiesIdStatisticsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StudiesIdStatisticsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\StudiesIdStatisticsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StudiesIdStatisticsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation studiesIdStatisticsGetAsync
     *
     * Get study statistics
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdStatisticsGetAsync($id, string $contentType = self::contentTypes['studiesIdStatisticsGet'][0])
    {
        return $this->studiesIdStatisticsGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation studiesIdStatisticsGetAsyncWithHttpInfo
     *
     * Get study statistics
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function studiesIdStatisticsGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['studiesIdStatisticsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StudiesIdStatisticsGet200Response';
        $request = $this->studiesIdStatisticsGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'studiesIdStatisticsGet'
     *
     * @param  string $id Orthanc identifier of the study of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['studiesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function studiesIdStatisticsGetRequest($id, string $contentType = self::contentTypes['studiesIdStatisticsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling studiesIdStatisticsGet'
            );
        }


        $resourcePath = '/studies/{id}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
