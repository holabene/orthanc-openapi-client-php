<?php
/**
 * InstancesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://book.orthanc-server.com/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://book.orthanc-server.com/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.11.3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * InstancesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class InstancesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'instancesGet' => [
            'application/json',
        ],
        'instancesIdAnonymizePost' => [
            'application/json',
        ],
        'instancesIdAttachmentsGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameCompressPost' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameCompressedDataGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameCompressedMd5Get' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameCompressedSizeGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameDataGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameDelete' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameInfoGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameIsCompressedGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameMd5Get' => [
            'application/json',
        ],
        'instancesIdAttachmentsNamePut' => [
            'application/octet-stream',
        ],
        'instancesIdAttachmentsNameSizeGet' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameUncompressPost' => [
            'application/json',
        ],
        'instancesIdAttachmentsNameVerifyMd5Post' => [
            'application/json',
        ],
        'instancesIdContentGet' => [
            'application/json',
        ],
        'instancesIdDelete' => [
            'application/json',
        ],
        'instancesIdExportPost' => [
            'text/plain',
        ],
        'instancesIdFileGet' => [
            'application/json',
        ],
        'instancesIdFramesFrameImageInt16Get' => [
            'application/json',
        ],
        'instancesIdFramesFrameImageUint16Get' => [
            'application/json',
        ],
        'instancesIdFramesFrameImageUint8Get' => [
            'application/json',
        ],
        'instancesIdFramesFrameMatlabGet' => [
            'application/json',
        ],
        'instancesIdFramesFrameNumpyGet' => [
            'application/json',
        ],
        'instancesIdFramesFramePreviewGet' => [
            'application/json',
        ],
        'instancesIdFramesFrameRawGet' => [
            'application/json',
        ],
        'instancesIdFramesFrameRawGzGet' => [
            'application/json',
        ],
        'instancesIdFramesFrameRenderedGet' => [
            'application/json',
        ],
        'instancesIdFramesGet' => [
            'application/json',
        ],
        'instancesIdGet' => [
            'application/json',
        ],
        'instancesIdHeaderGet' => [
            'application/json',
        ],
        'instancesIdImageInt16Get' => [
            'application/json',
        ],
        'instancesIdImageUint16Get' => [
            'application/json',
        ],
        'instancesIdImageUint8Get' => [
            'application/json',
        ],
        'instancesIdMatlabGet' => [
            'application/json',
        ],
        'instancesIdMetadataGet' => [
            'application/json',
        ],
        'instancesIdMetadataNameDelete' => [
            'application/json',
        ],
        'instancesIdMetadataNameGet' => [
            'application/json',
        ],
        'instancesIdMetadataNamePut' => [
            'text/plain',
        ],
        'instancesIdModifyPost' => [
            'application/json',
        ],
        'instancesIdModuleGet' => [
            'application/json',
        ],
        'instancesIdNumpyGet' => [
            'application/json',
        ],
        'instancesIdPatientGet' => [
            'application/json',
        ],
        'instancesIdPdfGet' => [
            'application/json',
        ],
        'instancesIdPreviewGet' => [
            'application/json',
        ],
        'instancesIdReconstructPost' => [
            'application/json',
        ],
        'instancesIdRenderedGet' => [
            'application/json',
        ],
        'instancesIdSeriesGet' => [
            'application/json',
        ],
        'instancesIdSimplifiedTagsGet' => [
            'application/json',
        ],
        'instancesIdStatisticsGet' => [
            'application/json',
        ],
        'instancesIdStudyGet' => [
            'application/json',
        ],
        'instancesIdTagsGet' => [
            'application/json',
        ],
        'instancesPost' => [
            'application/dicom',
            'application/zip',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation instancesGet
     *
     * List the available instances
     *
     * @param  string $expand If present, retrieve detailed information about the individual instances (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesGet($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['instancesGet'][0])
    {
        list($response) = $this->instancesGetWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType);
        return $response;
    }

    /**
     * Operation instancesGetWithHttpInfo
     *
     * List the available instances
     *
     * @param  string $expand If present, retrieve detailed information about the individual instances (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesGetWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['instancesGet'][0])
    {
        $request = $this->instancesGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesGetAsync
     *
     * List the available instances
     *
     * @param  string $expand If present, retrieve detailed information about the individual instances (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesGetAsync($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['instancesGet'][0])
    {
        return $this->instancesGetAsyncWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesGetAsyncWithHttpInfo
     *
     * List the available instances
     *
     * @param  string $expand If present, retrieve detailed information about the individual instances (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesGetAsyncWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['instancesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesGet'
     *
     * @param  string $expand If present, retrieve detailed information about the individual instances (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesGetRequest($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['instancesGet'][0])
    {








        $resourcePath = '/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAnonymizePost
     *
     * Anonymize instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdAnonymizePostRequest $instances_id_anonymize_post_request instances_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAnonymizePost($id, $instances_id_anonymize_post_request = null, string $contentType = self::contentTypes['instancesIdAnonymizePost'][0])
    {
        list($response) = $this->instancesIdAnonymizePostWithHttpInfo($id, $instances_id_anonymize_post_request, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAnonymizePostWithHttpInfo
     *
     * Anonymize instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdAnonymizePostRequest $instances_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAnonymizePostWithHttpInfo($id, $instances_id_anonymize_post_request = null, string $contentType = self::contentTypes['instancesIdAnonymizePost'][0])
    {
        $request = $this->instancesIdAnonymizePostRequest($id, $instances_id_anonymize_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAnonymizePostAsync
     *
     * Anonymize instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdAnonymizePostRequest $instances_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAnonymizePostAsync($id, $instances_id_anonymize_post_request = null, string $contentType = self::contentTypes['instancesIdAnonymizePost'][0])
    {
        return $this->instancesIdAnonymizePostAsyncWithHttpInfo($id, $instances_id_anonymize_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAnonymizePostAsyncWithHttpInfo
     *
     * Anonymize instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdAnonymizePostRequest $instances_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAnonymizePostAsyncWithHttpInfo($id, $instances_id_anonymize_post_request = null, string $contentType = self::contentTypes['instancesIdAnonymizePost'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAnonymizePostRequest($id, $instances_id_anonymize_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAnonymizePost'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdAnonymizePostRequest $instances_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAnonymizePostRequest($id, $instances_id_anonymize_post_request = null, string $contentType = self::contentTypes['instancesIdAnonymizePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAnonymizePost'
            );
        }



        $resourcePath = '/instances/{id}/anonymize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/dicom', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($instances_id_anonymize_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($instances_id_anonymize_post_request));
            } else {
                $httpBody = $instances_id_anonymize_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsGet
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsGet($id, $full = null, string $contentType = self::contentTypes['instancesIdAttachmentsGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsGetWithHttpInfo($id, $full, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsGetWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsGetWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['instancesIdAttachmentsGet'][0])
    {
        $request = $this->instancesIdAttachmentsGetRequest($id, $full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsGetAsync
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsGetAsync($id, $full = null, string $contentType = self::contentTypes['instancesIdAttachmentsGet'][0])
    {
        return $this->instancesIdAttachmentsGetAsyncWithHttpInfo($id, $full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsGetAsyncWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsGetAsyncWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['instancesIdAttachmentsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsGetRequest($id, $full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsGetRequest($id, $full = null, string $contentType = self::contentTypes['instancesIdAttachmentsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressPost
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdAttachmentsNameCompressPost($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressPost'][0])
    {
        $this->instancesIdAttachmentsNameCompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation instancesIdAttachmentsNameCompressPostWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameCompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressPost'][0])
    {
        $request = $this->instancesIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameCompressPostAsync
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressPostAsync($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressPost'][0])
    {
        return $this->instancesIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressPostAsyncWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressPost'][0])
    {
        $returnType = '';
        $request = $this->instancesIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameCompressPost'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameCompressPostRequest($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameCompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameCompressPost'
            );
        }


        $resourcePath = '/instances/{id}/attachments/{name}/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedDataGet
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameCompressedDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedDataGetWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'][0])
    {
        $request = $this->instancesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedDataGetAsync
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressedDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'][0])
    {
        return $this->instancesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameCompressedDataGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameCompressedDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameCompressedDataGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/compressed-data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedMd5Get
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameCompressedMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedMd5GetWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'][0])
    {
        $request = $this->instancesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedMd5GetAsync
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressedMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'][0])
    {
        return $this->instancesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameCompressedMd5Get'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameCompressedMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameCompressedMd5Get'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/compressed-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedSizeGet
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameCompressedSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedSizeGetWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'][0])
    {
        $request = $this->instancesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedSizeGetAsync
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressedSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'][0])
    {
        return $this->instancesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameCompressedSizeGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameCompressedSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameCompressedSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameCompressedSizeGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/compressed-size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameDataGet
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDataGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameDataGetWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDataGet'][0])
    {
        $request = $this->instancesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameDataGetAsync
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDataGet'][0])
    {
        return $this->instancesIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameDataGetAsyncWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameDataGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameDataGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameDelete
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdAttachmentsNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDelete'][0])
    {
        $this->instancesIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation instancesIdAttachmentsNameDeleteWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDelete'][0])
    {
        $request = $this->instancesIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameDeleteAsync
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDelete'][0])
    {
        return $this->instancesIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameDeleteAsyncWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDelete'][0])
    {
        $returnType = '';
        $request = $this->instancesIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameDelete'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameDelete'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameInfoGet
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameInfoGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameInfoGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameInfoGetWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameInfoGet'][0])
    {
        $request = $this->instancesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameInfoGetAsync
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameInfoGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameInfoGet'][0])
    {
        return $this->instancesIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameInfoGetAsyncWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameInfoGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameInfoGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameInfoGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameInfoGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameInfoGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameIsCompressedGet
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameIsCompressedGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameIsCompressedGetWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'][0])
    {
        $request = $this->instancesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameIsCompressedGetAsync
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameIsCompressedGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'][0])
    {
        return $this->instancesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameIsCompressedGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameIsCompressedGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameIsCompressedGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameIsCompressedGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/is-compressed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameMd5Get
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameMd5Get'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameMd5GetWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameMd5Get'][0])
    {
        $request = $this->instancesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameMd5GetAsync
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameMd5Get'][0])
    {
        return $this->instancesIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameMd5Get'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameMd5Get'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNamePut
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdAttachmentsNamePut'][0])
    {
        list($response) = $this->instancesIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNamePutWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdAttachmentsNamePut'][0])
    {
        $request = $this->instancesIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNamePutAsync
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdAttachmentsNamePut'][0])
    {
        return $this->instancesIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNamePutAsyncWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdAttachmentsNamePut'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNamePut'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdAttachmentsNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNamePut'
            );
        }




        $resourcePath = '/instances/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameSizeGet
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameSizeGet'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameSizeGetWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameSizeGet'][0])
    {
        $request = $this->instancesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameSizeGetAsync
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameSizeGet'][0])
    {
        return $this->instancesIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameSizeGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdAttachmentsNameSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameSizeGet'
            );
        }



        $resourcePath = '/instances/{id}/attachments/{name}/size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameUncompressPost
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdAttachmentsNameUncompressPost($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameUncompressPost'][0])
    {
        $this->instancesIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation instancesIdAttachmentsNameUncompressPostWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameUncompressPost'][0])
    {
        $request = $this->instancesIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameUncompressPostAsync
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameUncompressPostAsync($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameUncompressPost'][0])
    {
        return $this->instancesIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameUncompressPostAsyncWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameUncompressPost'][0])
    {
        $returnType = '';
        $request = $this->instancesIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameUncompressPost'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameUncompressPostRequest($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameUncompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameUncompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameUncompressPost'
            );
        }


        $resourcePath = '/instances/{id}/attachments/{name}/uncompress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdAttachmentsNameVerifyMd5Post
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdAttachmentsNameVerifyMd5Post($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'][0])
    {
        list($response) = $this->instancesIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdAttachmentsNameVerifyMd5PostWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'][0])
    {
        $request = $this->instancesIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdAttachmentsNameVerifyMd5PostAsync
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameVerifyMd5PostAsync($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'][0])
    {
        return $this->instancesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdAttachmentsNameVerifyMd5Post'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdAttachmentsNameVerifyMd5PostRequest($id, $name, string $contentType = self::contentTypes['instancesIdAttachmentsNameVerifyMd5Post'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdAttachmentsNameVerifyMd5Post'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdAttachmentsNameVerifyMd5Post'
            );
        }


        $resourcePath = '/instances/{id}/attachments/{name}/verify-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdContentGet
     *
     * Get raw tag
     *
     * @param  string $___ Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, &#x60;/0008-1140/1/0008-1150&#x60; (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdContentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdContentGet($___, $id, string $contentType = self::contentTypes['instancesIdContentGet'][0])
    {
        list($response) = $this->instancesIdContentGetWithHttpInfo($___, $id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdContentGetWithHttpInfo
     *
     * Get raw tag
     *
     * @param  string $___ Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, &#x60;/0008-1140/1/0008-1150&#x60; (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdContentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdContentGetWithHttpInfo($___, $id, string $contentType = self::contentTypes['instancesIdContentGet'][0])
    {
        $request = $this->instancesIdContentGetRequest($___, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdContentGetAsync
     *
     * Get raw tag
     *
     * @param  string $___ Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, &#x60;/0008-1140/1/0008-1150&#x60; (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdContentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdContentGetAsync($___, $id, string $contentType = self::contentTypes['instancesIdContentGet'][0])
    {
        return $this->instancesIdContentGetAsyncWithHttpInfo($___, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdContentGetAsyncWithHttpInfo
     *
     * Get raw tag
     *
     * @param  string $___ Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, &#x60;/0008-1140/1/0008-1150&#x60; (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdContentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdContentGetAsyncWithHttpInfo($___, $id, string $contentType = self::contentTypes['instancesIdContentGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdContentGetRequest($___, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdContentGet'
     *
     * @param  string $___ Path to the DICOM tag. This is the interleaving of one DICOM tag, possibly followed by an index for sequences. Sequences are accessible as, for instance, &#x60;/0008-1140/1/0008-1150&#x60; (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdContentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdContentGetRequest($___, $id, string $contentType = self::contentTypes['instancesIdContentGet'][0])
    {

        // verify the required parameter '___' is set
        if ($___ === null || (is_array($___) && count($___) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $___ when calling instancesIdContentGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdContentGet'
            );
        }


        $resourcePath = '/instances/{id}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($___ !== null) {
            $resourcePath = str_replace(
                '{' . '...' . '}',
                ObjectSerializer::toPathValue($___),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdDelete
     *
     * Delete some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdDelete($id, string $contentType = self::contentTypes['instancesIdDelete'][0])
    {
        $this->instancesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation instancesIdDeleteWithHttpInfo
     *
     * Delete some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdDelete'][0])
    {
        $request = $this->instancesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdDeleteAsync
     *
     * Delete some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdDeleteAsync($id, string $contentType = self::contentTypes['instancesIdDelete'][0])
    {
        return $this->instancesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdDeleteAsyncWithHttpInfo
     *
     * Delete some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdDelete'][0])
    {
        $returnType = '';
        $request = $this->instancesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdDelete'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdDeleteRequest($id, string $contentType = self::contentTypes['instancesIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdDelete'
            );
        }


        $resourcePath = '/instances/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdExportPost
     *
     * Write DICOM onto filesystem
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdExportPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdExportPost($id, $body = null, string $contentType = self::contentTypes['instancesIdExportPost'][0])
    {
        $this->instancesIdExportPostWithHttpInfo($id, $body, $contentType);
    }

    /**
     * Operation instancesIdExportPostWithHttpInfo
     *
     * Write DICOM onto filesystem
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdExportPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdExportPostWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['instancesIdExportPost'][0])
    {
        $request = $this->instancesIdExportPostRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdExportPostAsync
     *
     * Write DICOM onto filesystem
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdExportPostAsync($id, $body = null, string $contentType = self::contentTypes['instancesIdExportPost'][0])
    {
        return $this->instancesIdExportPostAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdExportPostAsyncWithHttpInfo
     *
     * Write DICOM onto filesystem
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdExportPostAsyncWithHttpInfo($id, $body = null, string $contentType = self::contentTypes['instancesIdExportPost'][0])
    {
        $returnType = '';
        $request = $this->instancesIdExportPostRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdExportPost'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdExportPostRequest($id, $body = null, string $contentType = self::contentTypes['instancesIdExportPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdExportPost'
            );
        }



        $resourcePath = '/instances/{id}/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFileGet
     *
     * Download DICOM
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $accept This HTTP header can be set to retrieve the DICOM instance in DICOMweb format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFileGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFileGet($id, $accept = null, string $contentType = self::contentTypes['instancesIdFileGet'][0])
    {
        list($response) = $this->instancesIdFileGetWithHttpInfo($id, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFileGetWithHttpInfo
     *
     * Download DICOM
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $accept This HTTP header can be set to retrieve the DICOM instance in DICOMweb format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFileGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFileGetWithHttpInfo($id, $accept = null, string $contentType = self::contentTypes['instancesIdFileGet'][0])
    {
        $request = $this->instancesIdFileGetRequest($id, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFileGetAsync
     *
     * Download DICOM
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $accept This HTTP header can be set to retrieve the DICOM instance in DICOMweb format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFileGetAsync($id, $accept = null, string $contentType = self::contentTypes['instancesIdFileGet'][0])
    {
        return $this->instancesIdFileGetAsyncWithHttpInfo($id, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFileGetAsyncWithHttpInfo
     *
     * Download DICOM
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $accept This HTTP header can be set to retrieve the DICOM instance in DICOMweb format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFileGetAsyncWithHttpInfo($id, $accept = null, string $contentType = self::contentTypes['instancesIdFileGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFileGetRequest($id, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFileGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $accept This HTTP header can be set to retrieve the DICOM instance in DICOMweb format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFileGetRequest($id, $accept = null, string $contentType = self::contentTypes['instancesIdFileGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFileGet'
            );
        }



        $resourcePath = '/instances/{id}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/dicom', 'application/dicom+json', 'application/dicom+xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameImageInt16Get
     *
     * Decode a frame (int16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageInt16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameImageInt16Get($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageInt16Get'][0])
    {
        list($response) = $this->instancesIdFramesFrameImageInt16GetWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameImageInt16GetWithHttpInfo
     *
     * Decode a frame (int16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageInt16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameImageInt16GetWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageInt16Get'][0])
    {
        $request = $this->instancesIdFramesFrameImageInt16GetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameImageInt16GetAsync
     *
     * Decode a frame (int16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageInt16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameImageInt16GetAsync($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageInt16Get'][0])
    {
        return $this->instancesIdFramesFrameImageInt16GetAsyncWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameImageInt16GetAsyncWithHttpInfo
     *
     * Decode a frame (int16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageInt16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameImageInt16GetAsyncWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageInt16Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameImageInt16GetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameImageInt16Get'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageInt16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameImageInt16GetRequest($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageInt16Get'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameImageInt16Get'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameImageInt16Get'
            );
        }





        $resourcePath = '/instances/{id}/frames/{frame}/image-int16';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameImageUint16Get
     *
     * Decode a frame (uint16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameImageUint16Get($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint16Get'][0])
    {
        list($response) = $this->instancesIdFramesFrameImageUint16GetWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameImageUint16GetWithHttpInfo
     *
     * Decode a frame (uint16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameImageUint16GetWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint16Get'][0])
    {
        $request = $this->instancesIdFramesFrameImageUint16GetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameImageUint16GetAsync
     *
     * Decode a frame (uint16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameImageUint16GetAsync($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint16Get'][0])
    {
        return $this->instancesIdFramesFrameImageUint16GetAsyncWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameImageUint16GetAsyncWithHttpInfo
     *
     * Decode a frame (uint16)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameImageUint16GetAsyncWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint16Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameImageUint16GetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameImageUint16Get'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameImageUint16GetRequest($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint16Get'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameImageUint16Get'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameImageUint16Get'
            );
        }





        $resourcePath = '/instances/{id}/frames/{frame}/image-uint16';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameImageUint8Get
     *
     * Decode a frame (uint8)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint8Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameImageUint8Get($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint8Get'][0])
    {
        list($response) = $this->instancesIdFramesFrameImageUint8GetWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameImageUint8GetWithHttpInfo
     *
     * Decode a frame (uint8)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint8Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameImageUint8GetWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint8Get'][0])
    {
        $request = $this->instancesIdFramesFrameImageUint8GetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameImageUint8GetAsync
     *
     * Decode a frame (uint8)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint8Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameImageUint8GetAsync($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint8Get'][0])
    {
        return $this->instancesIdFramesFrameImageUint8GetAsyncWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameImageUint8GetAsyncWithHttpInfo
     *
     * Decode a frame (uint8)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint8Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameImageUint8GetAsyncWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint8Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameImageUint8GetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameImageUint8Get'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameImageUint8Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameImageUint8GetRequest($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameImageUint8Get'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameImageUint8Get'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameImageUint8Get'
            );
        }





        $resourcePath = '/instances/{id}/frames/{frame}/image-uint8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameMatlabGet
     *
     * Decode frame for Matlab
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameMatlabGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameMatlabGet($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameMatlabGet'][0])
    {
        list($response) = $this->instancesIdFramesFrameMatlabGetWithHttpInfo($frame, $id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameMatlabGetWithHttpInfo
     *
     * Decode frame for Matlab
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameMatlabGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameMatlabGetWithHttpInfo($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameMatlabGet'][0])
    {
        $request = $this->instancesIdFramesFrameMatlabGetRequest($frame, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameMatlabGetAsync
     *
     * Decode frame for Matlab
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameMatlabGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameMatlabGetAsync($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameMatlabGet'][0])
    {
        return $this->instancesIdFramesFrameMatlabGetAsyncWithHttpInfo($frame, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameMatlabGetAsyncWithHttpInfo
     *
     * Decode frame for Matlab
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameMatlabGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameMatlabGetAsyncWithHttpInfo($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameMatlabGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameMatlabGetRequest($frame, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameMatlabGet'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameMatlabGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameMatlabGetRequest($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameMatlabGet'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameMatlabGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameMatlabGet'
            );
        }


        $resourcePath = '/instances/{id}/frames/{frame}/matlab';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameNumpyGet
     *
     * Decode frame for numpy
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameNumpyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameNumpyGet($frame, $id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdFramesFrameNumpyGet'][0])
    {
        list($response) = $this->instancesIdFramesFrameNumpyGetWithHttpInfo($frame, $id, $compress, $rescale, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameNumpyGetWithHttpInfo
     *
     * Decode frame for numpy
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameNumpyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameNumpyGetWithHttpInfo($frame, $id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdFramesFrameNumpyGet'][0])
    {
        $request = $this->instancesIdFramesFrameNumpyGetRequest($frame, $id, $compress, $rescale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameNumpyGetAsync
     *
     * Decode frame for numpy
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameNumpyGetAsync($frame, $id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdFramesFrameNumpyGet'][0])
    {
        return $this->instancesIdFramesFrameNumpyGetAsyncWithHttpInfo($frame, $id, $compress, $rescale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameNumpyGetAsyncWithHttpInfo
     *
     * Decode frame for numpy
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameNumpyGetAsyncWithHttpInfo($frame, $id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdFramesFrameNumpyGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameNumpyGetRequest($frame, $id, $compress, $rescale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameNumpyGet'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameNumpyGetRequest($frame, $id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdFramesFrameNumpyGet'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameNumpyGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameNumpyGet'
            );
        }




        $resourcePath = '/instances/{id}/frames/{frame}/numpy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $compress,
            'compress', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rescale,
            'rescale', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFramePreviewGet
     *
     * Decode a frame (preview)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFramePreviewGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFramePreviewGet($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFramePreviewGet'][0])
    {
        list($response) = $this->instancesIdFramesFramePreviewGetWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFramePreviewGetWithHttpInfo
     *
     * Decode a frame (preview)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFramePreviewGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFramePreviewGetWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFramePreviewGet'][0])
    {
        $request = $this->instancesIdFramesFramePreviewGetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFramePreviewGetAsync
     *
     * Decode a frame (preview)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFramePreviewGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFramePreviewGetAsync($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFramePreviewGet'][0])
    {
        return $this->instancesIdFramesFramePreviewGetAsyncWithHttpInfo($frame, $id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFramePreviewGetAsyncWithHttpInfo
     *
     * Decode a frame (preview)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFramePreviewGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFramePreviewGetAsyncWithHttpInfo($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFramePreviewGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFramePreviewGetRequest($frame, $id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFramePreviewGet'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFramePreviewGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFramePreviewGetRequest($frame, $id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFramePreviewGet'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFramePreviewGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFramePreviewGet'
            );
        }





        $resourcePath = '/instances/{id}/frames/{frame}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameRawGet
     *
     * Access raw frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameRawGet($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGet'][0])
    {
        list($response) = $this->instancesIdFramesFrameRawGetWithHttpInfo($frame, $id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameRawGetWithHttpInfo
     *
     * Access raw frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameRawGetWithHttpInfo($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGet'][0])
    {
        $request = $this->instancesIdFramesFrameRawGetRequest($frame, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameRawGetAsync
     *
     * Access raw frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameRawGetAsync($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGet'][0])
    {
        return $this->instancesIdFramesFrameRawGetAsyncWithHttpInfo($frame, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameRawGetAsyncWithHttpInfo
     *
     * Access raw frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameRawGetAsyncWithHttpInfo($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameRawGetRequest($frame, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameRawGet'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameRawGetRequest($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGet'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameRawGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameRawGet'
            );
        }


        $resourcePath = '/instances/{id}/frames/{frame}/raw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameRawGzGet
     *
     * Access raw frame (compressed)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGzGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameRawGzGet($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGzGet'][0])
    {
        list($response) = $this->instancesIdFramesFrameRawGzGetWithHttpInfo($frame, $id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameRawGzGetWithHttpInfo
     *
     * Access raw frame (compressed)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGzGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameRawGzGetWithHttpInfo($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGzGet'][0])
    {
        $request = $this->instancesIdFramesFrameRawGzGetRequest($frame, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameRawGzGetAsync
     *
     * Access raw frame (compressed)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGzGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameRawGzGetAsync($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGzGet'][0])
    {
        return $this->instancesIdFramesFrameRawGzGetAsyncWithHttpInfo($frame, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameRawGzGetAsyncWithHttpInfo
     *
     * Access raw frame (compressed)
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGzGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameRawGzGetAsyncWithHttpInfo($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGzGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameRawGzGetRequest($frame, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameRawGzGet'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRawGzGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameRawGzGetRequest($frame, $id, string $contentType = self::contentTypes['instancesIdFramesFrameRawGzGet'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameRawGzGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameRawGzGet'
            );
        }


        $resourcePath = '/instances/{id}/frames/{frame}/raw.gz';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/gzip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesFrameRenderedGet
     *
     * Render a frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRenderedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesFrameRenderedGet($frame, $id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameRenderedGet'][0])
    {
        list($response) = $this->instancesIdFramesFrameRenderedGetWithHttpInfo($frame, $id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesFrameRenderedGetWithHttpInfo
     *
     * Render a frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRenderedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesFrameRenderedGetWithHttpInfo($frame, $id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameRenderedGet'][0])
    {
        $request = $this->instancesIdFramesFrameRenderedGetRequest($frame, $id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesFrameRenderedGetAsync
     *
     * Render a frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRenderedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameRenderedGetAsync($frame, $id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameRenderedGet'][0])
    {
        return $this->instancesIdFramesFrameRenderedGetAsyncWithHttpInfo($frame, $id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesFrameRenderedGetAsyncWithHttpInfo
     *
     * Render a frame
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRenderedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesFrameRenderedGetAsyncWithHttpInfo($frame, $id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameRenderedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesFrameRenderedGetRequest($frame, $id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesFrameRenderedGet'
     *
     * @param  float $frame Index of the frame (starts at &#x60;0&#x60;) (required)
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesFrameRenderedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesFrameRenderedGetRequest($frame, $id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdFramesFrameRenderedGet'][0])
    {

        // verify the required parameter 'frame' is set
        if ($frame === null || (is_array($frame) && count($frame) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $frame when calling instancesIdFramesFrameRenderedGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesFrameRenderedGet'
            );
        }










        $resourcePath = '/instances/{id}/frames/{frame}/rendered';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $smooth,
            'smooth', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window_center,
            'window-center', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window_width,
            'window-width', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($frame !== null) {
            $resourcePath = str_replace(
                '{' . 'frame' . '}',
                ObjectSerializer::toPathValue($frame),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdFramesGet
     *
     * List available frames
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdFramesGet($id, string $contentType = self::contentTypes['instancesIdFramesGet'][0])
    {
        list($response) = $this->instancesIdFramesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdFramesGetWithHttpInfo
     *
     * List available frames
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdFramesGetWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdFramesGet'][0])
    {
        $request = $this->instancesIdFramesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdFramesGetAsync
     *
     * List available frames
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesGetAsync($id, string $contentType = self::contentTypes['instancesIdFramesGet'][0])
    {
        return $this->instancesIdFramesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdFramesGetAsyncWithHttpInfo
     *
     * List available frames
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdFramesGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdFramesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdFramesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdFramesGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdFramesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdFramesGetRequest($id, string $contentType = self::contentTypes['instancesIdFramesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdFramesGet'
            );
        }


        $resourcePath = '/instances/{id}/frames';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdGet
     *
     * Get information about some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdGet'][0])
    {
        list($response) = $this->instancesIdGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdGetWithHttpInfo
     *
     * Get information about some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdGet'][0])
    {
        $request = $this->instancesIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdGetAsync
     *
     * Get information about some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdGet'][0])
    {
        return $this->instancesIdGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdGetAsyncWithHttpInfo
     *
     * Get information about some instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdGet'
            );
        }





        $resourcePath = '/instances/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdHeaderGet
     *
     * Get DICOM meta-header
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdHeaderGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdHeaderGet($id, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdHeaderGet'][0])
    {
        list($response) = $this->instancesIdHeaderGetWithHttpInfo($id, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdHeaderGetWithHttpInfo
     *
     * Get DICOM meta-header
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdHeaderGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdHeaderGetWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdHeaderGet'][0])
    {
        $request = $this->instancesIdHeaderGetRequest($id, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdHeaderGetAsync
     *
     * Get DICOM meta-header
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdHeaderGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdHeaderGetAsync($id, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdHeaderGet'][0])
    {
        return $this->instancesIdHeaderGetAsyncWithHttpInfo($id, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdHeaderGetAsyncWithHttpInfo
     *
     * Get DICOM meta-header
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdHeaderGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdHeaderGetAsyncWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdHeaderGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdHeaderGetRequest($id, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdHeaderGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdHeaderGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdHeaderGetRequest($id, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdHeaderGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdHeaderGet'
            );
        }




        $resourcePath = '/instances/{id}/header';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdImageInt16Get
     *
     * Decode an image (int16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageInt16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdImageInt16Get($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageInt16Get'][0])
    {
        list($response) = $this->instancesIdImageInt16GetWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdImageInt16GetWithHttpInfo
     *
     * Decode an image (int16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageInt16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdImageInt16GetWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageInt16Get'][0])
    {
        $request = $this->instancesIdImageInt16GetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdImageInt16GetAsync
     *
     * Decode an image (int16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageInt16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdImageInt16GetAsync($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageInt16Get'][0])
    {
        return $this->instancesIdImageInt16GetAsyncWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdImageInt16GetAsyncWithHttpInfo
     *
     * Decode an image (int16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageInt16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdImageInt16GetAsyncWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageInt16Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdImageInt16GetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdImageInt16Get'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageInt16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdImageInt16GetRequest($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageInt16Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdImageInt16Get'
            );
        }





        $resourcePath = '/instances/{id}/image-int16';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdImageUint16Get
     *
     * Decode an image (uint16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdImageUint16Get($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint16Get'][0])
    {
        list($response) = $this->instancesIdImageUint16GetWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdImageUint16GetWithHttpInfo
     *
     * Decode an image (uint16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint16Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdImageUint16GetWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint16Get'][0])
    {
        $request = $this->instancesIdImageUint16GetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdImageUint16GetAsync
     *
     * Decode an image (uint16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdImageUint16GetAsync($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint16Get'][0])
    {
        return $this->instancesIdImageUint16GetAsyncWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdImageUint16GetAsyncWithHttpInfo
     *
     * Decode an image (uint16)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdImageUint16GetAsyncWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint16Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdImageUint16GetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdImageUint16Get'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint16Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdImageUint16GetRequest($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint16Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdImageUint16Get'
            );
        }





        $resourcePath = '/instances/{id}/image-uint16';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdImageUint8Get
     *
     * Decode an image (uint8)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint8Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdImageUint8Get($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint8Get'][0])
    {
        list($response) = $this->instancesIdImageUint8GetWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdImageUint8GetWithHttpInfo
     *
     * Decode an image (uint8)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint8Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdImageUint8GetWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint8Get'][0])
    {
        $request = $this->instancesIdImageUint8GetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdImageUint8GetAsync
     *
     * Decode an image (uint8)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint8Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdImageUint8GetAsync($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint8Get'][0])
    {
        return $this->instancesIdImageUint8GetAsyncWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdImageUint8GetAsyncWithHttpInfo
     *
     * Decode an image (uint8)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint8Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdImageUint8GetAsyncWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint8Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdImageUint8GetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdImageUint8Get'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdImageUint8Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdImageUint8GetRequest($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdImageUint8Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdImageUint8Get'
            );
        }





        $resourcePath = '/instances/{id}/image-uint8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdMatlabGet
     *
     * Decode frame for Matlab
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMatlabGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdMatlabGet($id, string $contentType = self::contentTypes['instancesIdMatlabGet'][0])
    {
        list($response) = $this->instancesIdMatlabGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdMatlabGetWithHttpInfo
     *
     * Decode frame for Matlab
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMatlabGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdMatlabGetWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdMatlabGet'][0])
    {
        $request = $this->instancesIdMatlabGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdMatlabGetAsync
     *
     * Decode frame for Matlab
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMatlabGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMatlabGetAsync($id, string $contentType = self::contentTypes['instancesIdMatlabGet'][0])
    {
        return $this->instancesIdMatlabGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdMatlabGetAsyncWithHttpInfo
     *
     * Decode frame for Matlab
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMatlabGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMatlabGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdMatlabGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdMatlabGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdMatlabGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMatlabGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdMatlabGetRequest($id, string $contentType = self::contentTypes['instancesIdMatlabGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdMatlabGet'
            );
        }


        $resourcePath = '/instances/{id}/matlab';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdMetadataGet
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdMetadataGet($id, $expand = null, string $contentType = self::contentTypes['instancesIdMetadataGet'][0])
    {
        list($response) = $this->instancesIdMetadataGetWithHttpInfo($id, $expand, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdMetadataGetWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdMetadataGetWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['instancesIdMetadataGet'][0])
    {
        $request = $this->instancesIdMetadataGetRequest($id, $expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdMetadataGetAsync
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataGetAsync($id, $expand = null, string $contentType = self::contentTypes['instancesIdMetadataGet'][0])
    {
        return $this->instancesIdMetadataGetAsyncWithHttpInfo($id, $expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdMetadataGetAsyncWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataGetAsyncWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['instancesIdMetadataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdMetadataGetRequest($id, $expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdMetadataGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdMetadataGetRequest($id, $expand = null, string $contentType = self::contentTypes['instancesIdMetadataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdMetadataGet'
            );
        }



        $resourcePath = '/instances/{id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdMetadataNameDelete
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdMetadataNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameDelete'][0])
    {
        $this->instancesIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation instancesIdMetadataNameDeleteWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameDelete'][0])
    {
        $request = $this->instancesIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdMetadataNameDeleteAsync
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameDelete'][0])
    {
        return $this->instancesIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdMetadataNameDeleteAsyncWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameDelete'][0])
    {
        $returnType = '';
        $request = $this->instancesIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdMetadataNameDelete'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdMetadataNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdMetadataNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdMetadataNameDelete'
            );
        }



        $resourcePath = '/instances/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdMetadataNameGet
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdMetadataNameGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameGet'][0])
    {
        list($response) = $this->instancesIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdMetadataNameGetWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameGet'][0])
    {
        $request = $this->instancesIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdMetadataNameGetAsync
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataNameGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameGet'][0])
    {
        return $this->instancesIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdMetadataNameGetAsyncWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdMetadataNameGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdMetadataNameGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['instancesIdMetadataNameGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdMetadataNameGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdMetadataNameGet'
            );
        }



        $resourcePath = '/instances/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdMetadataNamePut
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdMetadataNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdMetadataNamePut'][0])
    {
        $this->instancesIdMetadataNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
    }

    /**
     * Operation instancesIdMetadataNamePutWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdMetadataNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdMetadataNamePut'][0])
    {
        $request = $this->instancesIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdMetadataNamePutAsync
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdMetadataNamePut'][0])
    {
        return $this->instancesIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdMetadataNamePutAsyncWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdMetadataNamePut'][0])
    {
        $returnType = '';
        $request = $this->instancesIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdMetadataNamePut'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdMetadataNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['instancesIdMetadataNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdMetadataNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling instancesIdMetadataNamePut'
            );
        }




        $resourcePath = '/instances/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdModifyPost
     *
     * Modify instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdModifyPostRequest $instances_id_modify_post_request instances_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdModifyPost($id, $instances_id_modify_post_request = null, string $contentType = self::contentTypes['instancesIdModifyPost'][0])
    {
        list($response) = $this->instancesIdModifyPostWithHttpInfo($id, $instances_id_modify_post_request, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdModifyPostWithHttpInfo
     *
     * Modify instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdModifyPostRequest $instances_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdModifyPostWithHttpInfo($id, $instances_id_modify_post_request = null, string $contentType = self::contentTypes['instancesIdModifyPost'][0])
    {
        $request = $this->instancesIdModifyPostRequest($id, $instances_id_modify_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdModifyPostAsync
     *
     * Modify instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdModifyPostRequest $instances_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdModifyPostAsync($id, $instances_id_modify_post_request = null, string $contentType = self::contentTypes['instancesIdModifyPost'][0])
    {
        return $this->instancesIdModifyPostAsyncWithHttpInfo($id, $instances_id_modify_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdModifyPostAsyncWithHttpInfo
     *
     * Modify instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdModifyPostRequest $instances_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdModifyPostAsyncWithHttpInfo($id, $instances_id_modify_post_request = null, string $contentType = self::contentTypes['instancesIdModifyPost'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdModifyPostRequest($id, $instances_id_modify_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdModifyPost'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdModifyPostRequest $instances_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdModifyPostRequest($id, $instances_id_modify_post_request = null, string $contentType = self::contentTypes['instancesIdModifyPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdModifyPost'
            );
        }



        $resourcePath = '/instances/{id}/modify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/dicom', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($instances_id_modify_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($instances_id_modify_post_request));
            } else {
                $httpBody = $instances_id_modify_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdModuleGet
     *
     * Get instance module
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdModuleGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdModuleGet'][0])
    {
        list($response) = $this->instancesIdModuleGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdModuleGetWithHttpInfo
     *
     * Get instance module
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdModuleGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdModuleGet'][0])
    {
        $request = $this->instancesIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdModuleGetAsync
     *
     * Get instance module
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdModuleGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdModuleGet'][0])
    {
        return $this->instancesIdModuleGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdModuleGetAsyncWithHttpInfo
     *
     * Get instance module
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdModuleGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdModuleGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdModuleGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdModuleGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdModuleGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdModuleGet'
            );
        }





        $resourcePath = '/instances/{id}/module';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdNumpyGet
     *
     * Decode instance for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdNumpyGet($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdNumpyGet'][0])
    {
        list($response) = $this->instancesIdNumpyGetWithHttpInfo($id, $compress, $rescale, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdNumpyGetWithHttpInfo
     *
     * Decode instance for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdNumpyGetWithHttpInfo($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdNumpyGet'][0])
    {
        $request = $this->instancesIdNumpyGetRequest($id, $compress, $rescale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdNumpyGetAsync
     *
     * Decode instance for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdNumpyGetAsync($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdNumpyGet'][0])
    {
        return $this->instancesIdNumpyGetAsyncWithHttpInfo($id, $compress, $rescale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdNumpyGetAsyncWithHttpInfo
     *
     * Decode instance for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdNumpyGetAsyncWithHttpInfo($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdNumpyGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdNumpyGetRequest($id, $compress, $rescale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdNumpyGet'
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdNumpyGetRequest($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['instancesIdNumpyGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdNumpyGet'
            );
        }




        $resourcePath = '/instances/{id}/numpy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $compress,
            'compress', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rescale,
            'rescale', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdPatientGet
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdPatientGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdPatientGet'][0])
    {
        list($response) = $this->instancesIdPatientGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdPatientGetWithHttpInfo
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdPatientGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdPatientGet'][0])
    {
        $request = $this->instancesIdPatientGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdPatientGetAsync
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdPatientGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdPatientGet'][0])
    {
        return $this->instancesIdPatientGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdPatientGetAsyncWithHttpInfo
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdPatientGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdPatientGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdPatientGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdPatientGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdPatientGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdPatientGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdPatientGet'
            );
        }





        $resourcePath = '/instances/{id}/patient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdPdfGet
     *
     * Get embedded PDF
     *
     * @param  string $id Orthanc identifier of the instance interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPdfGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdPdfGet($id, string $contentType = self::contentTypes['instancesIdPdfGet'][0])
    {
        list($response) = $this->instancesIdPdfGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdPdfGetWithHttpInfo
     *
     * Get embedded PDF
     *
     * @param  string $id Orthanc identifier of the instance interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPdfGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdPdfGetWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdPdfGet'][0])
    {
        $request = $this->instancesIdPdfGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdPdfGetAsync
     *
     * Get embedded PDF
     *
     * @param  string $id Orthanc identifier of the instance interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPdfGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdPdfGetAsync($id, string $contentType = self::contentTypes['instancesIdPdfGet'][0])
    {
        return $this->instancesIdPdfGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdPdfGetAsyncWithHttpInfo
     *
     * Get embedded PDF
     *
     * @param  string $id Orthanc identifier of the instance interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPdfGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdPdfGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdPdfGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdPdfGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdPdfGet'
     *
     * @param  string $id Orthanc identifier of the instance interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPdfGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdPdfGetRequest($id, string $contentType = self::contentTypes['instancesIdPdfGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdPdfGet'
            );
        }


        $resourcePath = '/instances/{id}/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdPreviewGet
     *
     * Decode an image (preview)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPreviewGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdPreviewGet($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdPreviewGet'][0])
    {
        list($response) = $this->instancesIdPreviewGetWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdPreviewGetWithHttpInfo
     *
     * Decode an image (preview)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPreviewGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdPreviewGetWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdPreviewGet'][0])
    {
        $request = $this->instancesIdPreviewGetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdPreviewGetAsync
     *
     * Decode an image (preview)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPreviewGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdPreviewGetAsync($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdPreviewGet'][0])
    {
        return $this->instancesIdPreviewGetAsyncWithHttpInfo($id, $quality, $return_unsupported_image, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdPreviewGetAsyncWithHttpInfo
     *
     * Decode an image (preview)
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPreviewGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdPreviewGetAsyncWithHttpInfo($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdPreviewGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdPreviewGetRequest($id, $quality, $return_unsupported_image, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdPreviewGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdPreviewGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdPreviewGetRequest($id, $quality = null, $return_unsupported_image = null, $accept = null, string $contentType = self::contentTypes['instancesIdPreviewGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdPreviewGet'
            );
        }





        $resourcePath = '/instances/{id}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdReconstructPost
     *
     * Reconstruct tags &amp; optionally files of instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function instancesIdReconstructPost($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['instancesIdReconstructPost'][0])
    {
        $this->instancesIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType);
    }

    /**
     * Operation instancesIdReconstructPostWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['instancesIdReconstructPost'][0])
    {
        $request = $this->instancesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdReconstructPostAsync
     *
     * Reconstruct tags &amp; optionally files of instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdReconstructPostAsync($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['instancesIdReconstructPost'][0])
    {
        return $this->instancesIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdReconstructPostAsyncWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of instance
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['instancesIdReconstructPost'][0])
    {
        $returnType = '';
        $request = $this->instancesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdReconstructPost'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['instancesIdReconstructPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdReconstructPost'
            );
        }



        $resourcePath = '/instances/{id}/reconstruct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($instances_id_reconstruct_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($instances_id_reconstruct_post_request));
            } else {
                $httpBody = $instances_id_reconstruct_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdRenderedGet
     *
     * Render an image
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdRenderedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdRenderedGet($id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdRenderedGet'][0])
    {
        list($response) = $this->instancesIdRenderedGetWithHttpInfo($id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdRenderedGetWithHttpInfo
     *
     * Render an image
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdRenderedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdRenderedGetWithHttpInfo($id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdRenderedGet'][0])
    {
        $request = $this->instancesIdRenderedGetRequest($id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdRenderedGetAsync
     *
     * Render an image
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdRenderedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdRenderedGetAsync($id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdRenderedGet'][0])
    {
        return $this->instancesIdRenderedGetAsyncWithHttpInfo($id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdRenderedGetAsyncWithHttpInfo
     *
     * Render an image
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdRenderedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdRenderedGetAsyncWithHttpInfo($id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdRenderedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdRenderedGetRequest($id, $height, $quality, $return_unsupported_image, $smooth, $width, $window_center, $window_width, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdRenderedGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  float $height Height of the resized image (optional)
     * @param  float $quality Quality for JPEG images (between 1 and 100, defaults to 90) (optional)
     * @param  bool $return_unsupported_image Returns an unsupported.png placeholder image if unable to provide the image instead of returning a 415 HTTP error (defaults to false) (optional)
     * @param  bool $smooth Whether to smooth image on resize (optional)
     * @param  float $width Width of the resized image (optional)
     * @param  float $window_center Windowing center (optional)
     * @param  float $window_width Windowing width (optional)
     * @param  string $accept Format of the resulting image. Can be &#x60;image/png&#x60; (default), &#x60;image/jpeg&#x60; or &#x60;image/x-portable-arbitrarymap&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdRenderedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdRenderedGetRequest($id, $height = null, $quality = null, $return_unsupported_image = null, $smooth = null, $width = null, $window_center = null, $window_width = null, $accept = null, string $contentType = self::contentTypes['instancesIdRenderedGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdRenderedGet'
            );
        }










        $resourcePath = '/instances/{id}/rendered';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_unsupported_image,
            'returnUnsupportedImage', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $smooth,
            'smooth', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window_center,
            'window-center', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $window_width,
            'window-width', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/jpeg', 'image/png', 'image/x-portable-arbitrarymap', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdSeriesGet
     *
     * Get parent series
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdSeriesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdSeriesGet'][0])
    {
        list($response) = $this->instancesIdSeriesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdSeriesGetWithHttpInfo
     *
     * Get parent series
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdSeriesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdSeriesGet'][0])
    {
        $request = $this->instancesIdSeriesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdSeriesGetAsync
     *
     * Get parent series
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdSeriesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdSeriesGet'][0])
    {
        return $this->instancesIdSeriesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdSeriesGetAsyncWithHttpInfo
     *
     * Get parent series
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdSeriesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdSeriesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdSeriesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdSeriesGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdSeriesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdSeriesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdSeriesGet'
            );
        }





        $resourcePath = '/instances/{id}/series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdSimplifiedTagsGet
     *
     * Get human-readable tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSimplifiedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdSimplifiedTagsGet($id, $ignore_length = null, string $contentType = self::contentTypes['instancesIdSimplifiedTagsGet'][0])
    {
        list($response) = $this->instancesIdSimplifiedTagsGetWithHttpInfo($id, $ignore_length, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdSimplifiedTagsGetWithHttpInfo
     *
     * Get human-readable tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSimplifiedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdSimplifiedTagsGetWithHttpInfo($id, $ignore_length = null, string $contentType = self::contentTypes['instancesIdSimplifiedTagsGet'][0])
    {
        $request = $this->instancesIdSimplifiedTagsGetRequest($id, $ignore_length, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdSimplifiedTagsGetAsync
     *
     * Get human-readable tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSimplifiedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdSimplifiedTagsGetAsync($id, $ignore_length = null, string $contentType = self::contentTypes['instancesIdSimplifiedTagsGet'][0])
    {
        return $this->instancesIdSimplifiedTagsGetAsyncWithHttpInfo($id, $ignore_length, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdSimplifiedTagsGetAsyncWithHttpInfo
     *
     * Get human-readable tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSimplifiedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdSimplifiedTagsGetAsyncWithHttpInfo($id, $ignore_length = null, string $contentType = self::contentTypes['instancesIdSimplifiedTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdSimplifiedTagsGetRequest($id, $ignore_length, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdSimplifiedTagsGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdSimplifiedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdSimplifiedTagsGetRequest($id, $ignore_length = null, string $contentType = self::contentTypes['instancesIdSimplifiedTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdSimplifiedTagsGet'
            );
        }



        $resourcePath = '/instances/{id}/simplified-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdStatisticsGet
     *
     * Get instance statistics
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InstancesIdStatisticsGet200Response
     */
    public function instancesIdStatisticsGet($id, string $contentType = self::contentTypes['instancesIdStatisticsGet'][0])
    {
        list($response) = $this->instancesIdStatisticsGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdStatisticsGetWithHttpInfo
     *
     * Get instance statistics
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InstancesIdStatisticsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdStatisticsGetWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdStatisticsGet'][0])
    {
        $request = $this->instancesIdStatisticsGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InstancesIdStatisticsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\InstancesIdStatisticsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InstancesIdStatisticsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InstancesIdStatisticsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InstancesIdStatisticsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdStatisticsGetAsync
     *
     * Get instance statistics
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdStatisticsGetAsync($id, string $contentType = self::contentTypes['instancesIdStatisticsGet'][0])
    {
        return $this->instancesIdStatisticsGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdStatisticsGetAsyncWithHttpInfo
     *
     * Get instance statistics
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdStatisticsGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['instancesIdStatisticsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InstancesIdStatisticsGet200Response';
        $request = $this->instancesIdStatisticsGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdStatisticsGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdStatisticsGetRequest($id, string $contentType = self::contentTypes['instancesIdStatisticsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdStatisticsGet'
            );
        }


        $resourcePath = '/instances/{id}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdStudyGet
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdStudyGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdStudyGet'][0])
    {
        list($response) = $this->instancesIdStudyGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdStudyGetWithHttpInfo
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdStudyGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdStudyGet'][0])
    {
        $request = $this->instancesIdStudyGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdStudyGetAsync
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdStudyGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdStudyGet'][0])
    {
        return $this->instancesIdStudyGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdStudyGetAsyncWithHttpInfo
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdStudyGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdStudyGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdStudyGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdStudyGet'
     *
     * @param  string $id Orthanc identifier of the instance of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdStudyGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['instancesIdStudyGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdStudyGet'
            );
        }





        $resourcePath = '/instances/{id}/study';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesIdTagsGet
     *
     * Get DICOM tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function instancesIdTagsGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdTagsGet'][0])
    {
        list($response) = $this->instancesIdTagsGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation instancesIdTagsGetWithHttpInfo
     *
     * Get DICOM tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesIdTagsGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdTagsGet'][0])
    {
        $request = $this->instancesIdTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesIdTagsGetAsync
     *
     * Get DICOM tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdTagsGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdTagsGet'][0])
    {
        return $this->instancesIdTagsGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesIdTagsGetAsyncWithHttpInfo
     *
     * Get DICOM tags
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesIdTagsGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->instancesIdTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesIdTagsGet'
     *
     * @param  string $id Orthanc identifier of the DICOM instance of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesIdTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesIdTagsGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['instancesIdTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling instancesIdTagsGet'
            );
        }





        $resourcePath = '/instances/{id}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instancesPost
     *
     * Upload DICOM instances
     *
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InstancesPost200Response
     */
    public function instancesPost($body = null, string $contentType = self::contentTypes['instancesPost'][0])
    {
        list($response) = $this->instancesPostWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation instancesPostWithHttpInfo
     *
     * Upload DICOM instances
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InstancesPost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function instancesPostWithHttpInfo($body = null, string $contentType = self::contentTypes['instancesPost'][0])
    {
        $request = $this->instancesPostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InstancesPost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\InstancesPost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InstancesPost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InstancesPost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InstancesPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation instancesPostAsync
     *
     * Upload DICOM instances
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesPostAsync($body = null, string $contentType = self::contentTypes['instancesPost'][0])
    {
        return $this->instancesPostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instancesPostAsyncWithHttpInfo
     *
     * Upload DICOM instances
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instancesPostAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['instancesPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InstancesPost200Response';
        $request = $this->instancesPostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instancesPost'
     *
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instancesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instancesPostRequest($body = null, string $contentType = self::contentTypes['instancesPost'][0])
    {



        $resourcePath = '/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
