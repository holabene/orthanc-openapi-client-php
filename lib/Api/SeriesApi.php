<?php
/**
 * SeriesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://book.orthanc-server.com/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://book.orthanc-server.com/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.11.3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SeriesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SeriesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'seriesGet' => [
            'application/json',
        ],
        'seriesIdAnonymizePost' => [
            'application/json',
        ],
        'seriesIdArchiveGet' => [
            'application/json',
        ],
        'seriesIdArchivePost' => [
            'application/json',
        ],
        'seriesIdAttachmentsGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameCompressPost' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameCompressedDataGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameCompressedMd5Get' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameCompressedSizeGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameDataGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameDelete' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameInfoGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameIsCompressedGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameMd5Get' => [
            'application/json',
        ],
        'seriesIdAttachmentsNamePut' => [
            'application/octet-stream',
        ],
        'seriesIdAttachmentsNameSizeGet' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameUncompressPost' => [
            'application/json',
        ],
        'seriesIdAttachmentsNameVerifyMd5Post' => [
            'application/json',
        ],
        'seriesIdDelete' => [
            'application/json',
        ],
        'seriesIdGet' => [
            'application/json',
        ],
        'seriesIdInstancesGet' => [
            'application/json',
        ],
        'seriesIdInstancesTagsGet' => [
            'application/json',
        ],
        'seriesIdMediaGet' => [
            'application/json',
        ],
        'seriesIdMediaPost' => [
            'application/json',
        ],
        'seriesIdMetadataGet' => [
            'application/json',
        ],
        'seriesIdMetadataNameDelete' => [
            'application/json',
        ],
        'seriesIdMetadataNameGet' => [
            'application/json',
        ],
        'seriesIdMetadataNamePut' => [
            'text/plain',
        ],
        'seriesIdModifyPost' => [
            'application/json',
        ],
        'seriesIdModuleGet' => [
            'application/json',
        ],
        'seriesIdNumpyGet' => [
            'application/json',
        ],
        'seriesIdOrderedSlicesGet' => [
            'application/json',
        ],
        'seriesIdPatientGet' => [
            'application/json',
        ],
        'seriesIdReconstructPost' => [
            'application/json',
        ],
        'seriesIdSharedTagsGet' => [
            'application/json',
        ],
        'seriesIdStatisticsGet' => [
            'application/json',
        ],
        'seriesIdStudyGet' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation seriesGet
     *
     * List the available series
     *
     * @param  string $expand If present, retrieve detailed information about the individual series (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesGet($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['seriesGet'][0])
    {
        list($response) = $this->seriesGetWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType);
        return $response;
    }

    /**
     * Operation seriesGetWithHttpInfo
     *
     * List the available series
     *
     * @param  string $expand If present, retrieve detailed information about the individual series (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesGetWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['seriesGet'][0])
    {
        $request = $this->seriesGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesGetAsync
     *
     * List the available series
     *
     * @param  string $expand If present, retrieve detailed information about the individual series (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesGetAsync($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['seriesGet'][0])
    {
        return $this->seriesGetAsyncWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesGetAsyncWithHttpInfo
     *
     * List the available series
     *
     * @param  string $expand If present, retrieve detailed information about the individual series (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesGetAsyncWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['seriesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesGet'
     *
     * @param  string $expand If present, retrieve detailed information about the individual series (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesGetRequest($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['seriesGet'][0])
    {








        $resourcePath = '/series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAnonymizePost
     *
     * Anonymize series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function seriesIdAnonymizePost($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['seriesIdAnonymizePost'][0])
    {
        list($response) = $this->seriesIdAnonymizePostWithHttpInfo($id, $patients_id_anonymize_post_request, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAnonymizePostWithHttpInfo
     *
     * Anonymize series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAnonymizePostWithHttpInfo($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['seriesIdAnonymizePost'][0])
    {
        $request = $this->seriesIdAnonymizePostRequest($id, $patients_id_anonymize_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAnonymizePostAsync
     *
     * Anonymize series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAnonymizePostAsync($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['seriesIdAnonymizePost'][0])
    {
        return $this->seriesIdAnonymizePostAsyncWithHttpInfo($id, $patients_id_anonymize_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAnonymizePostAsyncWithHttpInfo
     *
     * Anonymize series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAnonymizePostAsyncWithHttpInfo($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['seriesIdAnonymizePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->seriesIdAnonymizePostRequest($id, $patients_id_anonymize_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAnonymizePost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAnonymizePostRequest($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['seriesIdAnonymizePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAnonymizePost'
            );
        }



        $resourcePath = '/series/{id}/anonymize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_anonymize_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_anonymize_post_request));
            } else {
                $httpBody = $patients_id_anonymize_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdArchiveGet
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdArchiveGet($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdArchiveGet'][0])
    {
        list($response) = $this->seriesIdArchiveGetWithHttpInfo($id, $filename, $transcode, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdArchiveGetWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdArchiveGetWithHttpInfo($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdArchiveGet'][0])
    {
        $request = $this->seriesIdArchiveGetRequest($id, $filename, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdArchiveGetAsync
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdArchiveGetAsync($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdArchiveGet'][0])
    {
        return $this->seriesIdArchiveGetAsyncWithHttpInfo($id, $filename, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdArchiveGetAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdArchiveGetAsyncWithHttpInfo($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdArchiveGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdArchiveGetRequest($id, $filename, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdArchiveGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdArchiveGetRequest($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdArchiveGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdArchiveGet'
            );
        }




        $resourcePath = '/series/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filename,
            'filename', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdArchivePost
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdArchivePost200Response
     */
    public function seriesIdArchivePost($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['seriesIdArchivePost'][0])
    {
        list($response) = $this->seriesIdArchivePostWithHttpInfo($id, $patients_id_archive_post_request, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdArchivePostWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdArchivePostWithHttpInfo($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['seriesIdArchivePost'][0])
    {
        $request = $this->seriesIdArchivePostRequest($id, $patients_id_archive_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdArchivePostAsync
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdArchivePostAsync($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['seriesIdArchivePost'][0])
    {
        return $this->seriesIdArchivePostAsyncWithHttpInfo($id, $patients_id_archive_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdArchivePostAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdArchivePostAsyncWithHttpInfo($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['seriesIdArchivePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
        $request = $this->seriesIdArchivePostRequest($id, $patients_id_archive_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdArchivePost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdArchivePostRequest($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['seriesIdArchivePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdArchivePost'
            );
        }



        $resourcePath = '/series/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_archive_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_archive_post_request));
            } else {
                $httpBody = $patients_id_archive_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsGet
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsGet($id, $full = null, string $contentType = self::contentTypes['seriesIdAttachmentsGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsGetWithHttpInfo($id, $full, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsGetWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsGetWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['seriesIdAttachmentsGet'][0])
    {
        $request = $this->seriesIdAttachmentsGetRequest($id, $full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsGetAsync
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsGetAsync($id, $full = null, string $contentType = self::contentTypes['seriesIdAttachmentsGet'][0])
    {
        return $this->seriesIdAttachmentsGetAsyncWithHttpInfo($id, $full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsGetAsyncWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsGetAsyncWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['seriesIdAttachmentsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsGetRequest($id, $full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsGetRequest($id, $full = null, string $contentType = self::contentTypes['seriesIdAttachmentsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsGet'
            );
        }



        $resourcePath = '/series/{id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressPost
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdAttachmentsNameCompressPost($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressPost'][0])
    {
        $this->seriesIdAttachmentsNameCompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation seriesIdAttachmentsNameCompressPostWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameCompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressPost'][0])
    {
        $request = $this->seriesIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameCompressPostAsync
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressPostAsync($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressPost'][0])
    {
        return $this->seriesIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressPostAsyncWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressPost'][0])
    {
        $returnType = '';
        $request = $this->seriesIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameCompressPost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameCompressPostRequest($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameCompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameCompressPost'
            );
        }


        $resourcePath = '/series/{id}/attachments/{name}/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedDataGet
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameCompressedDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedDataGetWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'][0])
    {
        $request = $this->seriesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedDataGetAsync
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressedDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'][0])
    {
        return $this->seriesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameCompressedDataGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameCompressedDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameCompressedDataGet'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/compressed-data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedMd5Get
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameCompressedMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedMd5GetWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'][0])
    {
        $request = $this->seriesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedMd5GetAsync
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressedMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'][0])
    {
        return $this->seriesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameCompressedMd5Get'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameCompressedMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameCompressedMd5Get'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/compressed-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedSizeGet
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameCompressedSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedSizeGetWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'][0])
    {
        $request = $this->seriesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedSizeGetAsync
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressedSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'][0])
    {
        return $this->seriesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameCompressedSizeGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameCompressedSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameCompressedSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameCompressedSizeGet'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/compressed-size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameDataGet
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDataGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameDataGetWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDataGet'][0])
    {
        $request = $this->seriesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameDataGetAsync
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDataGet'][0])
    {
        return $this->seriesIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameDataGetAsyncWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameDataGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameDataGet'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameDelete
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdAttachmentsNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDelete'][0])
    {
        $this->seriesIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation seriesIdAttachmentsNameDeleteWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDelete'][0])
    {
        $request = $this->seriesIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameDeleteAsync
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDelete'][0])
    {
        return $this->seriesIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameDeleteAsyncWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDelete'][0])
    {
        $returnType = '';
        $request = $this->seriesIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameDelete'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameDelete'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameInfoGet
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameInfoGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameInfoGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameInfoGetWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameInfoGet'][0])
    {
        $request = $this->seriesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameInfoGetAsync
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameInfoGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameInfoGet'][0])
    {
        return $this->seriesIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameInfoGetAsyncWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameInfoGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameInfoGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameInfoGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameInfoGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameInfoGet'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameIsCompressedGet
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameIsCompressedGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameIsCompressedGetWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'][0])
    {
        $request = $this->seriesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameIsCompressedGetAsync
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameIsCompressedGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'][0])
    {
        return $this->seriesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameIsCompressedGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameIsCompressedGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameIsCompressedGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameIsCompressedGet'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/is-compressed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameMd5Get
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameMd5Get'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameMd5GetWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameMd5Get'][0])
    {
        $request = $this->seriesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameMd5GetAsync
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameMd5Get'][0])
    {
        return $this->seriesIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameMd5Get'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameMd5Get'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNamePut
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdAttachmentsNamePut'][0])
    {
        list($response) = $this->seriesIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNamePutWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdAttachmentsNamePut'][0])
    {
        $request = $this->seriesIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNamePutAsync
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdAttachmentsNamePut'][0])
    {
        return $this->seriesIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNamePutAsyncWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdAttachmentsNamePut'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNamePut'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdAttachmentsNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNamePut'
            );
        }




        $resourcePath = '/series/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameSizeGet
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameSizeGet'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameSizeGetWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameSizeGet'][0])
    {
        $request = $this->seriesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameSizeGetAsync
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameSizeGet'][0])
    {
        return $this->seriesIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameSizeGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdAttachmentsNameSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameSizeGet'
            );
        }



        $resourcePath = '/series/{id}/attachments/{name}/size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameUncompressPost
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdAttachmentsNameUncompressPost($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameUncompressPost'][0])
    {
        $this->seriesIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation seriesIdAttachmentsNameUncompressPostWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameUncompressPost'][0])
    {
        $request = $this->seriesIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameUncompressPostAsync
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameUncompressPostAsync($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameUncompressPost'][0])
    {
        return $this->seriesIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameUncompressPostAsyncWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameUncompressPost'][0])
    {
        $returnType = '';
        $request = $this->seriesIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameUncompressPost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameUncompressPostRequest($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameUncompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameUncompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameUncompressPost'
            );
        }


        $resourcePath = '/series/{id}/attachments/{name}/uncompress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdAttachmentsNameVerifyMd5Post
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdAttachmentsNameVerifyMd5Post($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'][0])
    {
        list($response) = $this->seriesIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdAttachmentsNameVerifyMd5PostWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'][0])
    {
        $request = $this->seriesIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdAttachmentsNameVerifyMd5PostAsync
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameVerifyMd5PostAsync($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'][0])
    {
        return $this->seriesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdAttachmentsNameVerifyMd5Post'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdAttachmentsNameVerifyMd5PostRequest($id, $name, string $contentType = self::contentTypes['seriesIdAttachmentsNameVerifyMd5Post'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdAttachmentsNameVerifyMd5Post'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdAttachmentsNameVerifyMd5Post'
            );
        }


        $resourcePath = '/series/{id}/attachments/{name}/verify-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdDelete
     *
     * Delete some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdDelete($id, string $contentType = self::contentTypes['seriesIdDelete'][0])
    {
        $this->seriesIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation seriesIdDeleteWithHttpInfo
     *
     * Delete some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['seriesIdDelete'][0])
    {
        $request = $this->seriesIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdDeleteAsync
     *
     * Delete some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdDeleteAsync($id, string $contentType = self::contentTypes['seriesIdDelete'][0])
    {
        return $this->seriesIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdDeleteAsyncWithHttpInfo
     *
     * Delete some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['seriesIdDelete'][0])
    {
        $returnType = '';
        $request = $this->seriesIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdDelete'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdDeleteRequest($id, string $contentType = self::contentTypes['seriesIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdDelete'
            );
        }


        $resourcePath = '/series/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdGet
     *
     * Get information about some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdGet'][0])
    {
        list($response) = $this->seriesIdGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdGetWithHttpInfo
     *
     * Get information about some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdGet'][0])
    {
        $request = $this->seriesIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdGetAsync
     *
     * Get information about some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdGet'][0])
    {
        return $this->seriesIdGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdGetAsyncWithHttpInfo
     *
     * Get information about some series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdGet'
            );
        }





        $resourcePath = '/series/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdInstancesGet
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdInstancesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdInstancesGet'][0])
    {
        list($response) = $this->seriesIdInstancesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdInstancesGetWithHttpInfo
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdInstancesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdInstancesGet'][0])
    {
        $request = $this->seriesIdInstancesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdInstancesGetAsync
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdInstancesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdInstancesGet'][0])
    {
        return $this->seriesIdInstancesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdInstancesGetAsyncWithHttpInfo
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdInstancesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdInstancesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdInstancesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdInstancesGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdInstancesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdInstancesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdInstancesGet'
            );
        }





        $resourcePath = '/series/{id}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdInstancesTagsGet
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdInstancesTagsGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdInstancesTagsGet'][0])
    {
        list($response) = $this->seriesIdInstancesTagsGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdInstancesTagsGetWithHttpInfo
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdInstancesTagsGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdInstancesTagsGet'][0])
    {
        $request = $this->seriesIdInstancesTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdInstancesTagsGetAsync
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdInstancesTagsGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdInstancesTagsGet'][0])
    {
        return $this->seriesIdInstancesTagsGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdInstancesTagsGetAsyncWithHttpInfo
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdInstancesTagsGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdInstancesTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdInstancesTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdInstancesTagsGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdInstancesTagsGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdInstancesTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdInstancesTagsGet'
            );
        }





        $resourcePath = '/series/{id}/instances-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdMediaGet
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdMediaGet($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdMediaGet'][0])
    {
        list($response) = $this->seriesIdMediaGetWithHttpInfo($id, $extended, $filename, $transcode, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdMediaGetWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdMediaGetWithHttpInfo($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdMediaGet'][0])
    {
        $request = $this->seriesIdMediaGetRequest($id, $extended, $filename, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdMediaGetAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMediaGetAsync($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdMediaGet'][0])
    {
        return $this->seriesIdMediaGetAsyncWithHttpInfo($id, $extended, $filename, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdMediaGetAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMediaGetAsyncWithHttpInfo($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdMediaGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdMediaGetRequest($id, $extended, $filename, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdMediaGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdMediaGetRequest($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['seriesIdMediaGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdMediaGet'
            );
        }





        $resourcePath = '/series/{id}/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extended,
            'extended', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filename,
            'filename', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdMediaPost
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdArchivePost200Response
     */
    public function seriesIdMediaPost($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['seriesIdMediaPost'][0])
    {
        list($response) = $this->seriesIdMediaPostWithHttpInfo($id, $patients_id_media_post_request, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdMediaPostWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdMediaPostWithHttpInfo($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['seriesIdMediaPost'][0])
    {
        $request = $this->seriesIdMediaPostRequest($id, $patients_id_media_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdMediaPostAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMediaPostAsync($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['seriesIdMediaPost'][0])
    {
        return $this->seriesIdMediaPostAsyncWithHttpInfo($id, $patients_id_media_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdMediaPostAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMediaPostAsyncWithHttpInfo($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['seriesIdMediaPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
        $request = $this->seriesIdMediaPostRequest($id, $patients_id_media_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdMediaPost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdMediaPostRequest($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['seriesIdMediaPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdMediaPost'
            );
        }



        $resourcePath = '/series/{id}/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_media_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_media_post_request));
            } else {
                $httpBody = $patients_id_media_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdMetadataGet
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdMetadataGet($id, $expand = null, string $contentType = self::contentTypes['seriesIdMetadataGet'][0])
    {
        list($response) = $this->seriesIdMetadataGetWithHttpInfo($id, $expand, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdMetadataGetWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdMetadataGetWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['seriesIdMetadataGet'][0])
    {
        $request = $this->seriesIdMetadataGetRequest($id, $expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdMetadataGetAsync
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataGetAsync($id, $expand = null, string $contentType = self::contentTypes['seriesIdMetadataGet'][0])
    {
        return $this->seriesIdMetadataGetAsyncWithHttpInfo($id, $expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdMetadataGetAsyncWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataGetAsyncWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['seriesIdMetadataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdMetadataGetRequest($id, $expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdMetadataGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdMetadataGetRequest($id, $expand = null, string $contentType = self::contentTypes['seriesIdMetadataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdMetadataGet'
            );
        }



        $resourcePath = '/series/{id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdMetadataNameDelete
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdMetadataNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameDelete'][0])
    {
        $this->seriesIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation seriesIdMetadataNameDeleteWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameDelete'][0])
    {
        $request = $this->seriesIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdMetadataNameDeleteAsync
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameDelete'][0])
    {
        return $this->seriesIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdMetadataNameDeleteAsyncWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameDelete'][0])
    {
        $returnType = '';
        $request = $this->seriesIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdMetadataNameDelete'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdMetadataNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdMetadataNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdMetadataNameDelete'
            );
        }



        $resourcePath = '/series/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdMetadataNameGet
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdMetadataNameGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameGet'][0])
    {
        list($response) = $this->seriesIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdMetadataNameGetWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameGet'][0])
    {
        $request = $this->seriesIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdMetadataNameGetAsync
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataNameGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameGet'][0])
    {
        return $this->seriesIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdMetadataNameGetAsyncWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdMetadataNameGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdMetadataNameGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['seriesIdMetadataNameGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdMetadataNameGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdMetadataNameGet'
            );
        }



        $resourcePath = '/series/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdMetadataNamePut
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdMetadataNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdMetadataNamePut'][0])
    {
        $this->seriesIdMetadataNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
    }

    /**
     * Operation seriesIdMetadataNamePutWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdMetadataNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdMetadataNamePut'][0])
    {
        $request = $this->seriesIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdMetadataNamePutAsync
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdMetadataNamePut'][0])
    {
        return $this->seriesIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdMetadataNamePutAsyncWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdMetadataNamePut'][0])
    {
        $returnType = '';
        $request = $this->seriesIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdMetadataNamePut'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdMetadataNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['seriesIdMetadataNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdMetadataNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling seriesIdMetadataNamePut'
            );
        }




        $resourcePath = '/series/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdModifyPost
     *
     * Modify series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function seriesIdModifyPost($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['seriesIdModifyPost'][0])
    {
        list($response) = $this->seriesIdModifyPostWithHttpInfo($id, $patients_id_modify_post_request, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdModifyPostWithHttpInfo
     *
     * Modify series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdModifyPostWithHttpInfo($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['seriesIdModifyPost'][0])
    {
        $request = $this->seriesIdModifyPostRequest($id, $patients_id_modify_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdModifyPostAsync
     *
     * Modify series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdModifyPostAsync($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['seriesIdModifyPost'][0])
    {
        return $this->seriesIdModifyPostAsyncWithHttpInfo($id, $patients_id_modify_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdModifyPostAsyncWithHttpInfo
     *
     * Modify series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdModifyPostAsyncWithHttpInfo($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['seriesIdModifyPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->seriesIdModifyPostRequest($id, $patients_id_modify_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdModifyPost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdModifyPostRequest($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['seriesIdModifyPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdModifyPost'
            );
        }



        $resourcePath = '/series/{id}/modify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_modify_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_modify_post_request));
            } else {
                $httpBody = $patients_id_modify_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdModuleGet
     *
     * Get series module
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdModuleGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdModuleGet'][0])
    {
        list($response) = $this->seriesIdModuleGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdModuleGetWithHttpInfo
     *
     * Get series module
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdModuleGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdModuleGet'][0])
    {
        $request = $this->seriesIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdModuleGetAsync
     *
     * Get series module
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdModuleGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdModuleGet'][0])
    {
        return $this->seriesIdModuleGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdModuleGetAsyncWithHttpInfo
     *
     * Get series module
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdModuleGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdModuleGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdModuleGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdModuleGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdModuleGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdModuleGet'
            );
        }





        $resourcePath = '/series/{id}/module';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdNumpyGet
     *
     * Decode series for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdNumpyGet($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['seriesIdNumpyGet'][0])
    {
        list($response) = $this->seriesIdNumpyGetWithHttpInfo($id, $compress, $rescale, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdNumpyGetWithHttpInfo
     *
     * Decode series for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdNumpyGetWithHttpInfo($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['seriesIdNumpyGet'][0])
    {
        $request = $this->seriesIdNumpyGetRequest($id, $compress, $rescale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdNumpyGetAsync
     *
     * Decode series for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdNumpyGetAsync($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['seriesIdNumpyGet'][0])
    {
        return $this->seriesIdNumpyGetAsyncWithHttpInfo($id, $compress, $rescale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdNumpyGetAsyncWithHttpInfo
     *
     * Decode series for numpy
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdNumpyGetAsyncWithHttpInfo($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['seriesIdNumpyGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdNumpyGetRequest($id, $compress, $rescale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdNumpyGet'
     *
     * @param  string $id Orthanc identifier of the DICOM resource of interest (required)
     * @param  bool $compress Compress the file as &#x60;.npz&#x60; (optional)
     * @param  bool $rescale On grayscale images, apply the rescaling and return floating-point values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdNumpyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdNumpyGetRequest($id, $compress = null, $rescale = null, string $contentType = self::contentTypes['seriesIdNumpyGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdNumpyGet'
            );
        }




        $resourcePath = '/series/{id}/numpy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $compress,
            'compress', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rescale,
            'rescale', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdOrderedSlicesGet
     *
     * Order the slices
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdOrderedSlicesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response
     * @deprecated
     */
    public function seriesIdOrderedSlicesGet($id, string $contentType = self::contentTypes['seriesIdOrderedSlicesGet'][0])
    {
        list($response) = $this->seriesIdOrderedSlicesGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdOrderedSlicesGetWithHttpInfo
     *
     * Order the slices
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdOrderedSlicesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function seriesIdOrderedSlicesGetWithHttpInfo($id, string $contentType = self::contentTypes['seriesIdOrderedSlicesGet'][0])
    {
        $request = $this->seriesIdOrderedSlicesGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdOrderedSlicesGetAsync
     *
     * Order the slices
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdOrderedSlicesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function seriesIdOrderedSlicesGetAsync($id, string $contentType = self::contentTypes['seriesIdOrderedSlicesGet'][0])
    {
        return $this->seriesIdOrderedSlicesGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdOrderedSlicesGetAsyncWithHttpInfo
     *
     * Order the slices
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdOrderedSlicesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function seriesIdOrderedSlicesGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['seriesIdOrderedSlicesGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SeriesIdOrderedSlicesGet200Response';
        $request = $this->seriesIdOrderedSlicesGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdOrderedSlicesGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdOrderedSlicesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function seriesIdOrderedSlicesGetRequest($id, string $contentType = self::contentTypes['seriesIdOrderedSlicesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdOrderedSlicesGet'
            );
        }


        $resourcePath = '/series/{id}/ordered-slices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdPatientGet
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdPatientGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdPatientGet'][0])
    {
        list($response) = $this->seriesIdPatientGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdPatientGetWithHttpInfo
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdPatientGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdPatientGet'][0])
    {
        $request = $this->seriesIdPatientGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdPatientGetAsync
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdPatientGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdPatientGet'][0])
    {
        return $this->seriesIdPatientGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdPatientGetAsyncWithHttpInfo
     *
     * Get parent patient
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdPatientGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdPatientGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdPatientGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdPatientGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdPatientGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdPatientGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdPatientGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdPatientGet'
            );
        }





        $resourcePath = '/series/{id}/patient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdReconstructPost
     *
     * Reconstruct tags &amp; optionally files of series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function seriesIdReconstructPost($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['seriesIdReconstructPost'][0])
    {
        $this->seriesIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType);
    }

    /**
     * Operation seriesIdReconstructPostWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['seriesIdReconstructPost'][0])
    {
        $request = $this->seriesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdReconstructPostAsync
     *
     * Reconstruct tags &amp; optionally files of series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdReconstructPostAsync($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['seriesIdReconstructPost'][0])
    {
        return $this->seriesIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdReconstructPostAsyncWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of series
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['seriesIdReconstructPost'][0])
    {
        $returnType = '';
        $request = $this->seriesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdReconstructPost'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdReconstructPostRequest($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['seriesIdReconstructPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdReconstructPost'
            );
        }



        $resourcePath = '/series/{id}/reconstruct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($instances_id_reconstruct_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($instances_id_reconstruct_post_request));
            } else {
                $httpBody = $instances_id_reconstruct_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdSharedTagsGet
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdSharedTagsGet($id, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdSharedTagsGet'][0])
    {
        list($response) = $this->seriesIdSharedTagsGetWithHttpInfo($id, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdSharedTagsGetWithHttpInfo
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdSharedTagsGetWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdSharedTagsGet'][0])
    {
        $request = $this->seriesIdSharedTagsGetRequest($id, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdSharedTagsGetAsync
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdSharedTagsGetAsync($id, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdSharedTagsGet'][0])
    {
        return $this->seriesIdSharedTagsGetAsyncWithHttpInfo($id, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdSharedTagsGetAsyncWithHttpInfo
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdSharedTagsGetAsyncWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdSharedTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdSharedTagsGetRequest($id, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdSharedTagsGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdSharedTagsGetRequest($id, $short = null, $simplify = null, string $contentType = self::contentTypes['seriesIdSharedTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdSharedTagsGet'
            );
        }




        $resourcePath = '/series/{id}/shared-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdStatisticsGet
     *
     * Get series statistics
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SeriesIdStatisticsGet200Response
     */
    public function seriesIdStatisticsGet($id, string $contentType = self::contentTypes['seriesIdStatisticsGet'][0])
    {
        list($response) = $this->seriesIdStatisticsGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdStatisticsGetWithHttpInfo
     *
     * Get series statistics
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SeriesIdStatisticsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdStatisticsGetWithHttpInfo($id, string $contentType = self::contentTypes['seriesIdStatisticsGet'][0])
    {
        $request = $this->seriesIdStatisticsGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SeriesIdStatisticsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SeriesIdStatisticsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SeriesIdStatisticsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SeriesIdStatisticsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SeriesIdStatisticsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdStatisticsGetAsync
     *
     * Get series statistics
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdStatisticsGetAsync($id, string $contentType = self::contentTypes['seriesIdStatisticsGet'][0])
    {
        return $this->seriesIdStatisticsGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdStatisticsGetAsyncWithHttpInfo
     *
     * Get series statistics
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdStatisticsGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['seriesIdStatisticsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SeriesIdStatisticsGet200Response';
        $request = $this->seriesIdStatisticsGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdStatisticsGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdStatisticsGetRequest($id, string $contentType = self::contentTypes['seriesIdStatisticsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdStatisticsGet'
            );
        }


        $resourcePath = '/series/{id}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation seriesIdStudyGet
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function seriesIdStudyGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdStudyGet'][0])
    {
        list($response) = $this->seriesIdStudyGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation seriesIdStudyGetWithHttpInfo
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function seriesIdStudyGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdStudyGet'][0])
    {
        $request = $this->seriesIdStudyGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation seriesIdStudyGetAsync
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdStudyGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdStudyGet'][0])
    {
        return $this->seriesIdStudyGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation seriesIdStudyGetAsyncWithHttpInfo
     *
     * Get parent study
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function seriesIdStudyGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdStudyGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->seriesIdStudyGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'seriesIdStudyGet'
     *
     * @param  string $id Orthanc identifier of the series of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['seriesIdStudyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function seriesIdStudyGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['seriesIdStudyGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling seriesIdStudyGet'
            );
        }





        $resourcePath = '/series/{id}/study';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
