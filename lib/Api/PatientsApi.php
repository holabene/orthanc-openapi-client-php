<?php
/**
 * PatientsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Orthanc API
 *
 * This is the full documentation of the [REST API](https://book.orthanc-server.com/users/rest.html) of Orthanc.<p>This reference is automatically generated from the source code of Orthanc. A [shorter cheat sheet](https://book.orthanc-server.com/users/rest-cheatsheet.html) is part of the Orthanc Book.<p>An earlier, manually crafted version from August 2019, is [still available](2019-08-orthanc-openapi.html), but is not up-to-date anymore ([source](https://groups.google.com/g/orthanc-users/c/NUiJTEICSl8/m/xKeqMrbqAAAJ)).
 *
 * The version of the OpenAPI document: 1.11.3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PatientsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PatientsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'patientsGet' => [
            'application/json',
        ],
        'patientsIdAnonymizePost' => [
            'application/json',
        ],
        'patientsIdArchiveGet' => [
            'application/json',
        ],
        'patientsIdArchivePost' => [
            'application/json',
        ],
        'patientsIdAttachmentsGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameCompressPost' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameCompressedDataGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameCompressedMd5Get' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameCompressedSizeGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameDataGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameDelete' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameInfoGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameIsCompressedGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameMd5Get' => [
            'application/json',
        ],
        'patientsIdAttachmentsNamePut' => [
            'application/octet-stream',
        ],
        'patientsIdAttachmentsNameSizeGet' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameUncompressPost' => [
            'application/json',
        ],
        'patientsIdAttachmentsNameVerifyMd5Post' => [
            'application/json',
        ],
        'patientsIdDelete' => [
            'application/json',
        ],
        'patientsIdGet' => [
            'application/json',
        ],
        'patientsIdInstancesGet' => [
            'application/json',
        ],
        'patientsIdInstancesTagsGet' => [
            'application/json',
        ],
        'patientsIdMediaGet' => [
            'application/json',
        ],
        'patientsIdMediaPost' => [
            'application/json',
        ],
        'patientsIdMetadataGet' => [
            'application/json',
        ],
        'patientsIdMetadataNameDelete' => [
            'application/json',
        ],
        'patientsIdMetadataNameGet' => [
            'application/json',
        ],
        'patientsIdMetadataNamePut' => [
            'text/plain',
        ],
        'patientsIdModifyPost' => [
            'application/json',
        ],
        'patientsIdModuleGet' => [
            'application/json',
        ],
        'patientsIdProtectedGet' => [
            'application/json',
        ],
        'patientsIdProtectedPut' => [
            'application/json',
        ],
        'patientsIdReconstructPost' => [
            'application/json',
        ],
        'patientsIdSeriesGet' => [
            'application/json',
        ],
        'patientsIdSharedTagsGet' => [
            'application/json',
        ],
        'patientsIdStatisticsGet' => [
            'application/json',
        ],
        'patientsIdStudiesGet' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation patientsGet
     *
     * List the available patients
     *
     * @param  string $expand If present, retrieve detailed information about the individual patients (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsGet($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['patientsGet'][0])
    {
        list($response) = $this->patientsGetWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType);
        return $response;
    }

    /**
     * Operation patientsGetWithHttpInfo
     *
     * List the available patients
     *
     * @param  string $expand If present, retrieve detailed information about the individual patients (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsGetWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['patientsGet'][0])
    {
        $request = $this->patientsGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsGetAsync
     *
     * List the available patients
     *
     * @param  string $expand If present, retrieve detailed information about the individual patients (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsGetAsync($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['patientsGet'][0])
    {
        return $this->patientsGetAsyncWithHttpInfo($expand, $full, $limit, $requested_tags, $short, $since, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsGetAsyncWithHttpInfo
     *
     * List the available patients
     *
     * @param  string $expand If present, retrieve detailed information about the individual patients (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsGetAsyncWithHttpInfo($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['patientsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsGetRequest($expand, $full, $limit, $requested_tags, $short, $since, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsGet'
     *
     * @param  string $expand If present, retrieve detailed information about the individual patients (optional)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  float $limit Limit the number of results (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  float $since Show only the resources since the provided index (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsGetRequest($expand = null, $full = null, $limit = null, $requested_tags = null, $short = null, $since = null, string $contentType = self::contentTypes['patientsGet'][0])
    {








        $resourcePath = '/patients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAnonymizePost
     *
     * Anonymize patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function patientsIdAnonymizePost($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['patientsIdAnonymizePost'][0])
    {
        list($response) = $this->patientsIdAnonymizePostWithHttpInfo($id, $patients_id_anonymize_post_request, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAnonymizePostWithHttpInfo
     *
     * Anonymize patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAnonymizePostWithHttpInfo($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['patientsIdAnonymizePost'][0])
    {
        $request = $this->patientsIdAnonymizePostRequest($id, $patients_id_anonymize_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAnonymizePostAsync
     *
     * Anonymize patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAnonymizePostAsync($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['patientsIdAnonymizePost'][0])
    {
        return $this->patientsIdAnonymizePostAsyncWithHttpInfo($id, $patients_id_anonymize_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAnonymizePostAsyncWithHttpInfo
     *
     * Anonymize patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAnonymizePostAsyncWithHttpInfo($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['patientsIdAnonymizePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->patientsIdAnonymizePostRequest($id, $patients_id_anonymize_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAnonymizePost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdAnonymizePostRequest $patients_id_anonymize_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAnonymizePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAnonymizePostRequest($id, $patients_id_anonymize_post_request = null, string $contentType = self::contentTypes['patientsIdAnonymizePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAnonymizePost'
            );
        }



        $resourcePath = '/patients/{id}/anonymize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_anonymize_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_anonymize_post_request));
            } else {
                $httpBody = $patients_id_anonymize_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdArchiveGet
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdArchiveGet($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdArchiveGet'][0])
    {
        list($response) = $this->patientsIdArchiveGetWithHttpInfo($id, $filename, $transcode, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdArchiveGetWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdArchiveGetWithHttpInfo($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdArchiveGet'][0])
    {
        $request = $this->patientsIdArchiveGetRequest($id, $filename, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdArchiveGetAsync
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdArchiveGetAsync($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdArchiveGet'][0])
    {
        return $this->patientsIdArchiveGetAsyncWithHttpInfo($id, $filename, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdArchiveGetAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdArchiveGetAsyncWithHttpInfo($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdArchiveGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdArchiveGetRequest($id, $filename, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdArchiveGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdArchiveGetRequest($id, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdArchiveGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdArchiveGet'
            );
        }




        $resourcePath = '/patients/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filename,
            'filename', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdArchivePost
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchivePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdArchivePost200Response
     */
    public function patientsIdArchivePost($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['patientsIdArchivePost'][0])
    {
        list($response) = $this->patientsIdArchivePostWithHttpInfo($id, $patients_id_archive_post_request, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdArchivePostWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchivePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdArchivePostWithHttpInfo($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['patientsIdArchivePost'][0])
    {
        $request = $this->patientsIdArchivePostRequest($id, $patients_id_archive_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdArchivePostAsync
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdArchivePostAsync($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['patientsIdArchivePost'][0])
    {
        return $this->patientsIdArchivePostAsyncWithHttpInfo($id, $patients_id_archive_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdArchivePostAsyncWithHttpInfo
     *
     * Create ZIP archive
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdArchivePostAsyncWithHttpInfo($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['patientsIdArchivePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
        $request = $this->patientsIdArchivePostRequest($id, $patients_id_archive_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdArchivePost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdArchivePostRequest $patients_id_archive_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdArchivePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdArchivePostRequest($id, $patients_id_archive_post_request = null, string $contentType = self::contentTypes['patientsIdArchivePost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdArchivePost'
            );
        }



        $resourcePath = '/patients/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_archive_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_archive_post_request));
            } else {
                $httpBody = $patients_id_archive_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsGet
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsGet($id, $full = null, string $contentType = self::contentTypes['patientsIdAttachmentsGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsGetWithHttpInfo($id, $full, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsGetWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsGetWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['patientsIdAttachmentsGet'][0])
    {
        $request = $this->patientsIdAttachmentsGetRequest($id, $full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsGetAsync
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsGetAsync($id, $full = null, string $contentType = self::contentTypes['patientsIdAttachmentsGet'][0])
    {
        return $this->patientsIdAttachmentsGetAsyncWithHttpInfo($id, $full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsGetAsyncWithHttpInfo
     *
     * List attachments
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsGetAsyncWithHttpInfo($id, $full = null, string $contentType = self::contentTypes['patientsIdAttachmentsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsGetRequest($id, $full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $full If present, retrieve the attachments list and their numerical ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsGetRequest($id, $full = null, string $contentType = self::contentTypes['patientsIdAttachmentsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressPost
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdAttachmentsNameCompressPost($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressPost'][0])
    {
        $this->patientsIdAttachmentsNameCompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation patientsIdAttachmentsNameCompressPostWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameCompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressPost'][0])
    {
        $request = $this->patientsIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameCompressPostAsync
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressPostAsync($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressPost'][0])
    {
        return $this->patientsIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressPostAsyncWithHttpInfo
     *
     * Compress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressPost'][0])
    {
        $returnType = '';
        $request = $this->patientsIdAttachmentsNameCompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameCompressPost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameCompressPostRequest($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameCompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameCompressPost'
            );
        }


        $resourcePath = '/patients/{id}/attachments/{name}/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedDataGet
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameCompressedDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedDataGetWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameCompressedDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'][0])
    {
        $request = $this->patientsIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedDataGetAsync
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressedDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'][0])
    {
        return $this->patientsIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo
     *
     * Get attachment (no decompression)
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressedDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameCompressedDataGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameCompressedDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameCompressedDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameCompressedDataGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/compressed-data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedMd5Get
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameCompressedMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedMd5GetWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameCompressedMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'][0])
    {
        $request = $this->patientsIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedMd5GetAsync
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressedMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'][0])
    {
        return $this->patientsIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressedMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameCompressedMd5Get'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameCompressedMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameCompressedMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameCompressedMd5Get'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/compressed-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedSizeGet
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameCompressedSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedSizeGetWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameCompressedSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'][0])
    {
        $request = $this->patientsIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedSizeGetAsync
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressedSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'][0])
    {
        return $this->patientsIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment on disk
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameCompressedSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameCompressedSizeGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameCompressedSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameCompressedSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameCompressedSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameCompressedSizeGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/compressed-size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameDataGet
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameDataGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDataGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameDataGetWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameDataGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDataGet'][0])
    {
        $request = $this->patientsIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameDataGetAsync
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameDataGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDataGet'][0])
    {
        return $this->patientsIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameDataGetAsyncWithHttpInfo
     *
     * Get attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameDataGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameDataGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameDataGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameDataGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameDataGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameDataGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameDelete
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdAttachmentsNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDelete'][0])
    {
        $this->patientsIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation patientsIdAttachmentsNameDeleteWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDelete'][0])
    {
        $request = $this->patientsIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameDeleteAsync
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDelete'][0])
    {
        return $this->patientsIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameDeleteAsyncWithHttpInfo
     *
     * Delete attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDelete'][0])
    {
        $returnType = '';
        $request = $this->patientsIdAttachmentsNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameDelete'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameDelete'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameInfoGet
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameInfoGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameInfoGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameInfoGetWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameInfoGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameInfoGet'][0])
    {
        $request = $this->patientsIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameInfoGetAsync
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameInfoGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameInfoGet'][0])
    {
        return $this->patientsIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameInfoGetAsyncWithHttpInfo
     *
     * Get info about the attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameInfoGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameInfoGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameInfoGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameInfoGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameInfoGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameInfoGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameInfoGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameIsCompressedGet
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameIsCompressedGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameIsCompressedGetWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameIsCompressedGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'][0])
    {
        $request = $this->patientsIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameIsCompressedGetAsync
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameIsCompressedGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'][0])
    {
        return $this->patientsIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo
     *
     * Is attachment compressed?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameIsCompressedGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameIsCompressedGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameIsCompressedGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameIsCompressedGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameIsCompressedGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameIsCompressedGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/is-compressed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameMd5Get
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameMd5Get($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameMd5Get'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameMd5GetWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameMd5GetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameMd5Get'][0])
    {
        $request = $this->patientsIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameMd5GetAsync
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameMd5GetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameMd5Get'][0])
    {
        return $this->patientsIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameMd5GetAsyncWithHttpInfo
     *
     * Get MD5 of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameMd5GetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameMd5Get'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameMd5Get'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameMd5Get'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameMd5GetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameMd5Get'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameMd5Get'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameMd5Get'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNamePut
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdAttachmentsNamePut'][0])
    {
        list($response) = $this->patientsIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNamePutWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdAttachmentsNamePut'][0])
    {
        $request = $this->patientsIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNamePutAsync
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdAttachmentsNamePut'][0])
    {
        return $this->patientsIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNamePutAsyncWithHttpInfo
     *
     * Set attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdAttachmentsNamePut'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNamePut'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_match Revision of the attachment, if this is not the first time this attachment is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdAttachmentsNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNamePut'
            );
        }




        $resourcePath = '/patients/{id}/attachments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameSizeGet
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameSizeGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameSizeGet'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameSizeGetWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameSizeGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameSizeGet'][0])
    {
        $request = $this->patientsIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameSizeGetAsync
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameSizeGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameSizeGet'][0])
    {
        return $this->patientsIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameSizeGetAsyncWithHttpInfo
     *
     * Get size of attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameSizeGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameSizeGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameSizeGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the attachment, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameSizeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameSizeGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdAttachmentsNameSizeGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameSizeGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameSizeGet'
            );
        }



        $resourcePath = '/patients/{id}/attachments/{name}/size';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameUncompressPost
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdAttachmentsNameUncompressPost($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameUncompressPost'][0])
    {
        $this->patientsIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation patientsIdAttachmentsNameUncompressPostWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameUncompressPostWithHttpInfo($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameUncompressPost'][0])
    {
        $request = $this->patientsIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameUncompressPostAsync
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameUncompressPostAsync($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameUncompressPost'][0])
    {
        return $this->patientsIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameUncompressPostAsyncWithHttpInfo
     *
     * Uncompress attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameUncompressPostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameUncompressPost'][0])
    {
        $returnType = '';
        $request = $this->patientsIdAttachmentsNameUncompressPostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameUncompressPost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameUncompressPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameUncompressPostRequest($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameUncompressPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameUncompressPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameUncompressPost'
            );
        }


        $resourcePath = '/patients/{id}/attachments/{name}/uncompress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdAttachmentsNameVerifyMd5Post
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdAttachmentsNameVerifyMd5Post($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'][0])
    {
        list($response) = $this->patientsIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdAttachmentsNameVerifyMd5PostWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdAttachmentsNameVerifyMd5PostWithHttpInfo($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'][0])
    {
        $request = $this->patientsIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdAttachmentsNameVerifyMd5PostAsync
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameVerifyMd5PostAsync($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'][0])
    {
        return $this->patientsIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo
     *
     * Verify attachment
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdAttachmentsNameVerifyMd5PostAsyncWithHttpInfo($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdAttachmentsNameVerifyMd5PostRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdAttachmentsNameVerifyMd5Post'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the attachment, or its index (cf. &#x60;UserContentType&#x60; configuration option) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdAttachmentsNameVerifyMd5PostRequest($id, $name, string $contentType = self::contentTypes['patientsIdAttachmentsNameVerifyMd5Post'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdAttachmentsNameVerifyMd5Post'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdAttachmentsNameVerifyMd5Post'
            );
        }


        $resourcePath = '/patients/{id}/attachments/{name}/verify-md5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdDelete
     *
     * Delete some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdDelete($id, string $contentType = self::contentTypes['patientsIdDelete'][0])
    {
        $this->patientsIdDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation patientsIdDeleteWithHttpInfo
     *
     * Delete some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdDeleteWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdDelete'][0])
    {
        $request = $this->patientsIdDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdDeleteAsync
     *
     * Delete some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdDeleteAsync($id, string $contentType = self::contentTypes['patientsIdDelete'][0])
    {
        return $this->patientsIdDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdDeleteAsyncWithHttpInfo
     *
     * Delete some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdDelete'][0])
    {
        $returnType = '';
        $request = $this->patientsIdDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdDelete'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdDeleteRequest($id, string $contentType = self::contentTypes['patientsIdDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdDelete'
            );
        }


        $resourcePath = '/patients/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdGet
     *
     * Get information about some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdGet'][0])
    {
        list($response) = $this->patientsIdGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdGetWithHttpInfo
     *
     * Get information about some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdGet'][0])
    {
        $request = $this->patientsIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdGetAsync
     *
     * Get information about some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdGet'][0])
    {
        return $this->patientsIdGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdGetAsyncWithHttpInfo
     *
     * Get information about some patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdGet'
            );
        }





        $resourcePath = '/patients/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdInstancesGet
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdInstancesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdInstancesGet'][0])
    {
        list($response) = $this->patientsIdInstancesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdInstancesGetWithHttpInfo
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdInstancesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdInstancesGet'][0])
    {
        $request = $this->patientsIdInstancesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdInstancesGetAsync
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdInstancesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdInstancesGet'][0])
    {
        return $this->patientsIdInstancesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdInstancesGetAsyncWithHttpInfo
     *
     * Get child instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdInstancesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdInstancesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdInstancesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdInstancesGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdInstancesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdInstancesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdInstancesGet'
            );
        }





        $resourcePath = '/patients/{id}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdInstancesTagsGet
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdInstancesTagsGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdInstancesTagsGet'][0])
    {
        list($response) = $this->patientsIdInstancesTagsGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdInstancesTagsGetWithHttpInfo
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdInstancesTagsGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdInstancesTagsGet'][0])
    {
        $request = $this->patientsIdInstancesTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdInstancesTagsGetAsync
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdInstancesTagsGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdInstancesTagsGet'][0])
    {
        return $this->patientsIdInstancesTagsGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdInstancesTagsGetAsyncWithHttpInfo
     *
     * Get tags of instances
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdInstancesTagsGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdInstancesTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdInstancesTagsGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdInstancesTagsGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdInstancesTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdInstancesTagsGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdInstancesTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdInstancesTagsGet'
            );
        }





        $resourcePath = '/patients/{id}/instances-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdMediaGet
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdMediaGet($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdMediaGet'][0])
    {
        list($response) = $this->patientsIdMediaGetWithHttpInfo($id, $extended, $filename, $transcode, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdMediaGetWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdMediaGetWithHttpInfo($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdMediaGet'][0])
    {
        $request = $this->patientsIdMediaGetRequest($id, $extended, $filename, $transcode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdMediaGetAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMediaGetAsync($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdMediaGet'][0])
    {
        return $this->patientsIdMediaGetAsyncWithHttpInfo($id, $extended, $filename, $transcode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdMediaGetAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMediaGetAsyncWithHttpInfo($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdMediaGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdMediaGetRequest($id, $extended, $filename, $transcode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdMediaGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $extended If present, will include additional tags such as &#x60;SeriesDescription&#x60;, leading to a so-called *extended DICOMDIR* (optional)
     * @param  string $filename Filename to set in the \&quot;Content-Disposition\&quot; HTTP header (including file extension) (optional)
     * @param  string $transcode If present, the DICOM files in the archive will be transcoded to the provided transfer syntax: https://book.orthanc-server.com/faq/transcoding.html (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdMediaGetRequest($id, $extended = null, $filename = null, $transcode = null, string $contentType = self::contentTypes['patientsIdMediaGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdMediaGet'
            );
        }





        $resourcePath = '/patients/{id}/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extended,
            'extended', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filename,
            'filename', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode,
            'transcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdMediaPost
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdArchivePost200Response
     */
    public function patientsIdMediaPost($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['patientsIdMediaPost'][0])
    {
        list($response) = $this->patientsIdMediaPostWithHttpInfo($id, $patients_id_media_post_request, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdMediaPostWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdArchivePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdMediaPostWithHttpInfo($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['patientsIdMediaPost'][0])
    {
        $request = $this->patientsIdMediaPostRequest($id, $patients_id_media_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdArchivePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdArchivePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdArchivePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdMediaPostAsync
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMediaPostAsync($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['patientsIdMediaPost'][0])
    {
        return $this->patientsIdMediaPostAsyncWithHttpInfo($id, $patients_id_media_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdMediaPostAsyncWithHttpInfo
     *
     * Create DICOMDIR media
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMediaPostAsyncWithHttpInfo($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['patientsIdMediaPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdArchivePost200Response';
        $request = $this->patientsIdMediaPostRequest($id, $patients_id_media_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdMediaPost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdMediaPostRequest $patients_id_media_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMediaPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdMediaPostRequest($id, $patients_id_media_post_request = null, string $contentType = self::contentTypes['patientsIdMediaPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdMediaPost'
            );
        }



        $resourcePath = '/patients/{id}/media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_media_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_media_post_request));
            } else {
                $httpBody = $patients_id_media_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdMetadataGet
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdMetadataGet($id, $expand = null, string $contentType = self::contentTypes['patientsIdMetadataGet'][0])
    {
        list($response) = $this->patientsIdMetadataGetWithHttpInfo($id, $expand, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdMetadataGetWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdMetadataGetWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['patientsIdMetadataGet'][0])
    {
        $request = $this->patientsIdMetadataGetRequest($id, $expand, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdMetadataGetAsync
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataGetAsync($id, $expand = null, string $contentType = self::contentTypes['patientsIdMetadataGet'][0])
    {
        return $this->patientsIdMetadataGetAsyncWithHttpInfo($id, $expand, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdMetadataGetAsyncWithHttpInfo
     *
     * List metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataGetAsyncWithHttpInfo($id, $expand = null, string $contentType = self::contentTypes['patientsIdMetadataGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdMetadataGetRequest($id, $expand, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdMetadataGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $expand If present, also retrieve the value of the individual metadata (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdMetadataGetRequest($id, $expand = null, string $contentType = self::contentTypes['patientsIdMetadataGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdMetadataGet'
            );
        }



        $resourcePath = '/patients/{id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdMetadataNameDelete
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdMetadataNameDelete($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameDelete'][0])
    {
        $this->patientsIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match, $contentType);
    }

    /**
     * Operation patientsIdMetadataNameDeleteWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdMetadataNameDeleteWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameDelete'][0])
    {
        $request = $this->patientsIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdMetadataNameDeleteAsync
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataNameDeleteAsync($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameDelete'][0])
    {
        return $this->patientsIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdMetadataNameDeleteAsyncWithHttpInfo
     *
     * Delete metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataNameDeleteAsyncWithHttpInfo($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameDelete'][0])
    {
        $returnType = '';
        $request = $this->patientsIdMetadataNameDeleteRequest($id, $name, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdMetadataNameDelete'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, to check if its content has not changed and can be deleted. This header is mandatory if &#x60;CheckRevisions&#x60; option is &#x60;true&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdMetadataNameDeleteRequest($id, $name, $if_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdMetadataNameDelete'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdMetadataNameDelete'
            );
        }



        $resourcePath = '/patients/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdMetadataNameGet
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdMetadataNameGet($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameGet'][0])
    {
        list($response) = $this->patientsIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdMetadataNameGetWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdMetadataNameGetWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameGet'][0])
    {
        $request = $this->patientsIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdMetadataNameGetAsync
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataNameGetAsync($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameGet'][0])
    {
        return $this->patientsIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdMetadataNameGetAsyncWithHttpInfo
     *
     * Get metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataNameGetAsyncWithHttpInfo($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdMetadataNameGetRequest($id, $name, $if_none_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdMetadataNameGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_none_match Optional revision of the metadata, to check if its content has changed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNameGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdMetadataNameGetRequest($id, $name, $if_none_match = null, string $contentType = self::contentTypes['patientsIdMetadataNameGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdMetadataNameGet'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdMetadataNameGet'
            );
        }



        $resourcePath = '/patients/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdMetadataNamePut
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdMetadataNamePut($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdMetadataNamePut'][0])
    {
        $this->patientsIdMetadataNamePutWithHttpInfo($id, $name, $if_match, $body, $contentType);
    }

    /**
     * Operation patientsIdMetadataNamePutWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdMetadataNamePutWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdMetadataNamePut'][0])
    {
        $request = $this->patientsIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdMetadataNamePutAsync
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataNamePutAsync($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdMetadataNamePut'][0])
    {
        return $this->patientsIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdMetadataNamePutAsyncWithHttpInfo
     *
     * Set metadata
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdMetadataNamePutAsyncWithHttpInfo($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdMetadataNamePut'][0])
    {
        $returnType = '';
        $request = $this->patientsIdMetadataNamePutRequest($id, $name, $if_match, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdMetadataNamePut'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $name The name of the metadata, or its index (cf. &#x60;UserMetadata&#x60; configuration option) (required)
     * @param  string $if_match Revision of the metadata, if this is not the first time this metadata is set. (optional)
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdMetadataNamePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdMetadataNamePutRequest($id, $name, $if_match = null, $body = null, string $contentType = self::contentTypes['patientsIdMetadataNamePut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdMetadataNamePut'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patientsIdMetadataNamePut'
            );
        }




        $resourcePath = '/patients/{id}/metadata/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdModifyPost
     *
     * Modify patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModalitiesIdMovePost200Response
     */
    public function patientsIdModifyPost($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['patientsIdModifyPost'][0])
    {
        list($response) = $this->patientsIdModifyPostWithHttpInfo($id, $patients_id_modify_post_request, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdModifyPostWithHttpInfo
     *
     * Modify patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModifyPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModalitiesIdMovePost200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdModifyPostWithHttpInfo($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['patientsIdModifyPost'][0])
    {
        $request = $this->patientsIdModifyPostRequest($id, $patients_id_modify_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModalitiesIdMovePost200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdModifyPostAsync
     *
     * Modify patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdModifyPostAsync($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['patientsIdModifyPost'][0])
    {
        return $this->patientsIdModifyPostAsyncWithHttpInfo($id, $patients_id_modify_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdModifyPostAsyncWithHttpInfo
     *
     * Modify patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdModifyPostAsyncWithHttpInfo($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['patientsIdModifyPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModalitiesIdMovePost200Response';
        $request = $this->patientsIdModifyPostRequest($id, $patients_id_modify_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdModifyPost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\PatientsIdModifyPostRequest $patients_id_modify_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModifyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdModifyPostRequest($id, $patients_id_modify_post_request = null, string $contentType = self::contentTypes['patientsIdModifyPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdModifyPost'
            );
        }



        $resourcePath = '/patients/{id}/modify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patients_id_modify_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patients_id_modify_post_request));
            } else {
                $httpBody = $patients_id_modify_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdModuleGet
     *
     * Get patient module
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdModuleGet($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdModuleGet'][0])
    {
        list($response) = $this->patientsIdModuleGetWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdModuleGetWithHttpInfo
     *
     * Get patient module
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModuleGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdModuleGetWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdModuleGet'][0])
    {
        $request = $this->patientsIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdModuleGetAsync
     *
     * Get patient module
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdModuleGetAsync($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdModuleGet'][0])
    {
        return $this->patientsIdModuleGetAsyncWithHttpInfo($id, $ignore_length, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdModuleGetAsyncWithHttpInfo
     *
     * Get patient module
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdModuleGetAsyncWithHttpInfo($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdModuleGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdModuleGetRequest($id, $ignore_length, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdModuleGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string[] $ignore_length Also include the DICOM tags that are provided in this list, even if their associated value is long (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdModuleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdModuleGetRequest($id, $ignore_length = null, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdModuleGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdModuleGet'
            );
        }





        $resourcePath = '/patients/{id}/module';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_length,
            'ignore-length', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdProtectedGet
     *
     * Is the patient protected against recycling?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdProtectedGet($id, string $contentType = self::contentTypes['patientsIdProtectedGet'][0])
    {
        list($response) = $this->patientsIdProtectedGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdProtectedGetWithHttpInfo
     *
     * Is the patient protected against recycling?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdProtectedGetWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdProtectedGet'][0])
    {
        $request = $this->patientsIdProtectedGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdProtectedGetAsync
     *
     * Is the patient protected against recycling?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdProtectedGetAsync($id, string $contentType = self::contentTypes['patientsIdProtectedGet'][0])
    {
        return $this->patientsIdProtectedGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdProtectedGetAsyncWithHttpInfo
     *
     * Is the patient protected against recycling?
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdProtectedGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdProtectedGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdProtectedGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdProtectedGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdProtectedGetRequest($id, string $contentType = self::contentTypes['patientsIdProtectedGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdProtectedGet'
            );
        }


        $resourcePath = '/patients/{id}/protected';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdProtectedPut
     *
     * Protect one patient against recycling
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdProtectedPut($id, string $contentType = self::contentTypes['patientsIdProtectedPut'][0])
    {
        $this->patientsIdProtectedPutWithHttpInfo($id, $contentType);
    }

    /**
     * Operation patientsIdProtectedPutWithHttpInfo
     *
     * Protect one patient against recycling
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdProtectedPutWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdProtectedPut'][0])
    {
        $request = $this->patientsIdProtectedPutRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdProtectedPutAsync
     *
     * Protect one patient against recycling
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdProtectedPutAsync($id, string $contentType = self::contentTypes['patientsIdProtectedPut'][0])
    {
        return $this->patientsIdProtectedPutAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdProtectedPutAsyncWithHttpInfo
     *
     * Protect one patient against recycling
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdProtectedPutAsyncWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdProtectedPut'][0])
    {
        $returnType = '';
        $request = $this->patientsIdProtectedPutRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdProtectedPut'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdProtectedPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdProtectedPutRequest($id, string $contentType = self::contentTypes['patientsIdProtectedPut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdProtectedPut'
            );
        }


        $resourcePath = '/patients/{id}/protected';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdReconstructPost
     *
     * Reconstruct tags &amp; optionally files of patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patientsIdReconstructPost($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['patientsIdReconstructPost'][0])
    {
        $this->patientsIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType);
    }

    /**
     * Operation patientsIdReconstructPostWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdReconstructPostWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['patientsIdReconstructPost'][0])
    {
        $request = $this->patientsIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdReconstructPostAsync
     *
     * Reconstruct tags &amp; optionally files of patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdReconstructPostAsync($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['patientsIdReconstructPost'][0])
    {
        return $this->patientsIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdReconstructPostAsyncWithHttpInfo
     *
     * Reconstruct tags &amp; optionally files of patient
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdReconstructPostAsyncWithHttpInfo($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['patientsIdReconstructPost'][0])
    {
        $returnType = '';
        $request = $this->patientsIdReconstructPostRequest($id, $instances_id_reconstruct_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdReconstructPost'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  \OpenAPI\Client\Model\InstancesIdReconstructPostRequest $instances_id_reconstruct_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdReconstructPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdReconstructPostRequest($id, $instances_id_reconstruct_post_request = null, string $contentType = self::contentTypes['patientsIdReconstructPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdReconstructPost'
            );
        }



        $resourcePath = '/patients/{id}/reconstruct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($instances_id_reconstruct_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($instances_id_reconstruct_post_request));
            } else {
                $httpBody = $instances_id_reconstruct_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdSeriesGet
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdSeriesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdSeriesGet'][0])
    {
        list($response) = $this->patientsIdSeriesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdSeriesGetWithHttpInfo
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdSeriesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdSeriesGet'][0])
    {
        $request = $this->patientsIdSeriesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdSeriesGetAsync
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdSeriesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdSeriesGet'][0])
    {
        return $this->patientsIdSeriesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdSeriesGetAsyncWithHttpInfo
     *
     * Get child series
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdSeriesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdSeriesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdSeriesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdSeriesGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSeriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdSeriesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdSeriesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdSeriesGet'
            );
        }





        $resourcePath = '/patients/{id}/series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdSharedTagsGet
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdSharedTagsGet($id, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdSharedTagsGet'][0])
    {
        list($response) = $this->patientsIdSharedTagsGetWithHttpInfo($id, $short, $simplify, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdSharedTagsGetWithHttpInfo
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdSharedTagsGetWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdSharedTagsGet'][0])
    {
        $request = $this->patientsIdSharedTagsGetRequest($id, $short, $simplify, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdSharedTagsGetAsync
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdSharedTagsGetAsync($id, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdSharedTagsGet'][0])
    {
        return $this->patientsIdSharedTagsGetAsyncWithHttpInfo($id, $short, $simplify, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdSharedTagsGetAsyncWithHttpInfo
     *
     * Get shared tags
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdSharedTagsGetAsyncWithHttpInfo($id, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdSharedTagsGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdSharedTagsGetRequest($id, $short, $simplify, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdSharedTagsGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  bool $simplify If present, report the DICOM tags in human-readable format (using the symbolic name of the tags) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdSharedTagsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdSharedTagsGetRequest($id, $short = null, $simplify = null, string $contentType = self::contentTypes['patientsIdSharedTagsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdSharedTagsGet'
            );
        }




        $resourcePath = '/patients/{id}/shared-tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $simplify,
            'simplify', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdStatisticsGet
     *
     * Get patient statistics
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientsIdStatisticsGet200Response
     */
    public function patientsIdStatisticsGet($id, string $contentType = self::contentTypes['patientsIdStatisticsGet'][0])
    {
        list($response) = $this->patientsIdStatisticsGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdStatisticsGetWithHttpInfo
     *
     * Get patient statistics
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientsIdStatisticsGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdStatisticsGetWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdStatisticsGet'][0])
    {
        $request = $this->patientsIdStatisticsGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientsIdStatisticsGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientsIdStatisticsGet200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientsIdStatisticsGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientsIdStatisticsGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientsIdStatisticsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdStatisticsGetAsync
     *
     * Get patient statistics
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdStatisticsGetAsync($id, string $contentType = self::contentTypes['patientsIdStatisticsGet'][0])
    {
        return $this->patientsIdStatisticsGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdStatisticsGetAsyncWithHttpInfo
     *
     * Get patient statistics
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdStatisticsGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['patientsIdStatisticsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientsIdStatisticsGet200Response';
        $request = $this->patientsIdStatisticsGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdStatisticsGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdStatisticsGetRequest($id, string $contentType = self::contentTypes['patientsIdStatisticsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdStatisticsGet'
            );
        }


        $resourcePath = '/patients/{id}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patientsIdStudiesGet
     *
     * Get child studies
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStudiesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function patientsIdStudiesGet($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdStudiesGet'][0])
    {
        list($response) = $this->patientsIdStudiesGetWithHttpInfo($id, $full, $requested_tags, $short, $contentType);
        return $response;
    }

    /**
     * Operation patientsIdStudiesGetWithHttpInfo
     *
     * Get child studies
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStudiesGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function patientsIdStudiesGetWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdStudiesGet'][0])
    {
        $request = $this->patientsIdStudiesGetRequest($id, $full, $requested_tags, $short, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('mixed' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'mixed', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'mixed';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patientsIdStudiesGetAsync
     *
     * Get child studies
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStudiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdStudiesGetAsync($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdStudiesGet'][0])
    {
        return $this->patientsIdStudiesGetAsyncWithHttpInfo($id, $full, $requested_tags, $short, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patientsIdStudiesGetAsyncWithHttpInfo
     *
     * Get child studies
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStudiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patientsIdStudiesGetAsyncWithHttpInfo($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdStudiesGet'][0])
    {
        $returnType = 'mixed';
        $request = $this->patientsIdStudiesGetRequest($id, $full, $requested_tags, $short, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patientsIdStudiesGet'
     *
     * @param  string $id Orthanc identifier of the patient of interest (required)
     * @param  bool $full If present, report the DICOM tags in full format (tags indexed by their hexadecimal format, associated with their symbolic name and their value) (optional)
     * @param  string $requested_tags If present, list the DICOM Tags you want to list in the response.  This argument is a semi-column separated list of DICOM Tags identifiers; e.g: &#39;requestedTags&#x3D;0010,0010;PatientBirthDate&#39;.  The tags requested tags are returned in the &#39;RequestedTags&#39; field in the response.  Note that, if you are requesting tags that are not listed in the Main Dicom Tags stored in DB, building the response might be slow since Orthanc will need to access the DICOM files.  If not specified, Orthanc will return (optional)
     * @param  bool $short If present, report the DICOM tags in hexadecimal format (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patientsIdStudiesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patientsIdStudiesGetRequest($id, $full = null, $requested_tags = null, $short = null, string $contentType = self::contentTypes['patientsIdStudiesGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling patientsIdStudiesGet'
            );
        }





        $resourcePath = '/patients/{id}/studies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full,
            'full', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requested_tags,
            'requestedTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $short,
            'short', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
